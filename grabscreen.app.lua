#!/usr/bin/env luajit

-- Application unity file generated by mkapp.lua of LJClang, see
-- https://github.com/helixhorned/ljclang
-- NOTE: this does not say anything about the authorship or any
--  other property of the constituent files of this amalgamation!

local __LJClang_MkApp_Modules = {require}
-- mkapp.lua: override require() ========================================================================
local require
do
  local error=error
  local orig_require=__LJClang_MkApp_Modules[1]
  __LJClang_MkApp_Modules[1]=nil

  require = function(m)
    local t=__LJClang_MkApp_Modules[m]
    if t==nil then error("module '"..m.."' not included in .app.lua, please contact app and/or mkapp.lua maintainer") end
    return (t==true) and orig_require(m) or t
  end
end
-- mkapp.lua: built-in modules =========================================================================
__LJClang_MkApp_Modules["ffi"]=true
__LJClang_MkApp_Modules["bit"]=true
__LJClang_MkApp_Modules["io"]=true
__LJClang_MkApp_Modules["math"]=true
__LJClang_MkApp_Modules["os"]=true
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["error_util"]=(function()
local assert = assert
local error = error
local type = type

----------

local api = {}

-- TODO: default 'level' to 2 for the following two functions?

-- Wrap 'error' in assert-like call to write type checks in one line instead of three.
function api.check(pred, msg, level)
    if (not pred) then
        error(msg, level+1)
    end
end

function api.checktype(object, argIdx, typename, level)
    -- NOTE: type(nil) returns nil. We disallow passing nil for `typename` however:
    -- the resulting check would be "is <object>'s type anything other than nil" rather than
    -- the more likely intended "is <object>'s type nil (in other words, is it nil?)".
    assert(type(argIdx) == "number")
    assert(type(typename) == "string")

    if (type(object) ~= typename) then
        local msg = "argument #"..argIdx.." must be a "..typename.." (got "..type(object)..")"
        error(msg, level+1)
    end
end

-- Done!
return api
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["class"]=(function()

local ffi = require("ffi")

local assert = assert
local error = error
local pairs = pairs
local setmetatable = setmetatable
local tostring = tostring
local type = type

local check = require("error_util").check

----------

local api = {}

function api.class(tab)
    check(type(tab) == "table", "argument must be a table", 2)

    -- The generated metatable
    local mt = { __metatable="class" }
    local ctor

    -- Whether we have "plain" string keys, that is, ones not starting with two underscores.
    local havePlainKeys = false

    -- check tab contents
    for k,v in pairs(tab) do
        if (k == 1) then
            -- constructor: a function that returns a table, or string
            -- containing struct definition.
            local isCType = (type(v) == "cdata" and tostring(v):match("^ctype<"))
            check(type(v) == "function" or type(v) == "string" or isCType,
                  "tab[1] must be a function, string or ctype", 2)
            ctor = v
        elseif (type(k) == "string") then
            check(type(v) == "function" or type(v) == "string",
                  "tab[<string>] must be a function or a string", 2)
            if (k:sub(1,2) == "__") then
                if (k == "__index") then
                    check(type(v) == "function", "tab.__index must be a function", 2)
                elseif (k == "__gc") then
                    error("__gc does not work, use ffi.gc() instead", 2)
                end
            else
                havePlainKeys = true
            end
        else
            error("tab can contain entries at [1], or string keys", 2)
        end
    end

    local __index_tab = {}
    local __index_func = tab.__index

    if (__index_func ~= nil and havePlainKeys) then
        -- The case where 'tab' has both key '__index' (which then must be a function, as
        -- checked above), as well as convenience string keys.
        error("tab has both __index and convenience __index entries", 2)
    elseif (havePlainKeys) then
        mt.__index = __index_tab
    elseif (__index_func ~= nil) then
        mt.__index = __index_func
    end

    check(ctor ~= nil, "must provide a constructor in tab[1]")
    tab[1] = nil

    -- Create the metatable by taking over the contents of the one passed to us.
    for k,v in pairs(tab) do
        assert(type(k) == "string")

        if (type(v) == "string") then  -- alias
            v = tab[v]
        end

        if (k:sub(1,2) == "__") then
            if (k ~= "__index") then
                mt[k] = v
            end
        else
            __index_tab[k] = v
        end
    end

    if (type(ctor) == "function") then
        local factory = function(...)
            local t = ctor(...)
            check(t == nil or type(t) == "table", "constructor must return nil or a table", 2)
            if (t ~= nil) then
                return setmetatable(t, mt)
            end
        end

        return factory
    else
        local ct = (type(ctor) == "string") and "struct {"..ctor.."}" or ctor
        return ffi.metatype(ct, mt)
    end
end

-- Done!
return api
end)()
-- mkapp.lua: built-in modules =========================================================================
__LJClang_MkApp_Modules["string"]=true
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["posix_types"]=(function()
local ffi=require"ffi"

local assert = assert

----------

ffi.cdef[[
typedef unsigned int __uid_t;
typedef long __off_t;
typedef int __pid_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef int __clockid_t;
typedef int __ssize_t;
typedef unsigned int __socklen_t;
typedef __time_t time_t;
typedef __suseconds_t suseconds_t;
typedef __uid_t uid_t;
typedef __off_t off_t;
typedef __pid_t pid_t;
typedef __ssize_t ssize_t;
typedef __clockid_t clockid_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
typedef unsigned long nfds_t;

typedef
struct { uint32_t v_[32]; }
fd_set;

typedef
struct { uint32_t v_[32]; }
sigset_t;
]]

-- Unused, but kept for generation. See POSIX sys/types.h
--[[
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long __clock_t;
typedef unsigned int __id_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsfilcnt_t;
typedef __ino_t ino_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __id_t id_t;
typedef __clock_t clock_t;
typedef __blksize_t blksize_t;
typedef __blkcnt_t blkcnt_t;
typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;
]]

-- NOTE: members of time structs have the 'tv_' prefix stripped.
ffi.cdef[[
struct timeval {
    time_t sec;
    suseconds_t usec;
};

struct timespec {
    time_t sec;
    long   nsec;
};

struct pollfd {
    int   fd;
    short events;
    short revents;
};
]]

-- Check that on our system, the structs we want to expose include *only* the members
-- specified by POSIX.
assert(ffi.sizeof("struct timeval") ==
8
)
assert(ffi.sizeof("struct timespec") ==
8
)
assert(ffi.sizeof("struct pollfd") ==
8
)

return {}
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["posix_decls"]=(function()
local ffi=require"ffi"

local assert = assert
local tonumber = tonumber

----------

local SIG_DFL = [[
((__sighandler_t)0)
]]
-- Check that SIG_DFL is #defined as a null pointer cast.
assert(SIG_DFL:match([[^%(%(.*%)0%)
$]]))

ffi.cdef[[
struct dirent64;
]]

local d_name_offsets = {
["struct dirent"]=11,
["struct dirent64"]=19,
}
local dirent64_name_offset
do
    local offset = d_name_offsets["struct dirent"]
    local offset64 = d_name_offsets["struct dirent64"]

    -- glibc: we (deliberately) did not pass _D_FILE_OFFSET_BITS=64 to see the 32-bit
    --  __{ino,off}_t 'struct dirent'. We avoid using 'struct dirent' since it is defined
    --  differently depending on '#ifndef __USE_FILE_OFFSET64'.
    local isGlibc = ((offset ~= nil and offset64 ~= nil) and offset < offset64)
    -- musl: off_t is always 64-bit (see FAQ), definition of 'struct dirent' is always the
    --  same, but there is no 'dirent64' exposed as actual type, only as #define which our
    --  extractdecls path does not see through. It *is* possible to use 'readdir64' from
    --  LuaJIT though -- the symbol is present and just redirects to 'readdir', presumably.
    local isMusl = (offset64 == nil and offset ~= nil)
    assert(isGlibc or isMusl)

    dirent64_name_offset = isGlibc and offset64 or offset
    -- Ensure cross-build compatibility wrt this particular binary interface aspect.
    -- All the dance above just for that...
    assert(dirent64_name_offset == 19)
end

local uint8_ptr_t = ffi.typeof("const uint8_t *")
local dirent64_ptr_t = ffi.typeof("struct dirent64 *")

return {

getDirent64Name = function(dirent)
    assert(ffi.istype(dirent64_ptr_t, dirent))
    assert(dirent ~= nil)
    local ptr = ffi.cast(uint8_ptr_t, dirent) + dirent64_name_offset
    return ffi.string(ptr)
end,

POLL = ffi.new[[struct {
static const int IN = 0x001;
}]],
-- NOTE: PF -> AF
AF = ffi.new[[struct {
static const int INET = 2;
}]],
CLOCK = ffi.new[[struct {
static const int MONOTONIC = 1;
}]],
E = ffi.new[[struct {
static const int AGAIN = 11;
static const int NODEV = 19;
static const int PIPE = 32;
}]],
F = ffi.new[[struct {
static const int GETFL = 3;
static const int SETFL = 4;
}]],
MAP = ffi.new[[struct {
static const int SHARED = 0x01;
static const int PRIVATE = 0x02;
static const int FIXED = 0x10;
}]],
O = ffi.new[[struct {
static const int RDONLY = 00;
static const int WRONLY = 01;
static const int RDWR = 02;
static const int NONBLOCK = 04000;
}]],
PROT = ffi.new[[struct {
static const int READ = 0x1;
static const int WRITE = 0x2;
static const int NONE = 0x0;
}]],
_SC = ffi.new[[struct {
static const int PAGESIZE = 30;
}]],
SHUT = ffi.new[[struct {
static const int RDWR = 2;
}]],
SIG = ffi.new[[struct {
static const int INT = 2;
static const int PIPE = 13;
static const int BLOCK = 0;
}]],
SOCK = ffi.new[[struct {
static const int STREAM = 1;
}]],

}
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["ljclang_linux_decls"]=(function()
local ffi=require"ffi"
ffi.cdef[[
int inotify_init();
int inotify_init1(int);
int inotify_add_watch(int, const char *, uint32_t);
int inotify_rm_watch(int, int);
]]
return {
IN = ffi.new[[struct {
static const int ACCESS = 0x00000001;
static const int MODIFY = 0x00000002;
static const int ATTRIB = 0x00000004;
static const int CLOSE_WRITE = 0x00000008;
static const int CLOSE_NOWRITE = 0x00000010;
static const int OPEN = 0x00000020;
static const int MOVED_FROM = 0x00000040;
static const int MOVED_TO = 0x00000080;
static const int CREATE = 0x00000100;
static const int DELETE = 0x00000200;
static const int DELETE_SELF = 0x00000400;
static const int MOVE_SELF = 0x00000800;
static const int UNMOUNT = 0x00002000;
static const int Q_OVERFLOW = 0x00004000;
static const int IGNORED = 0x00008000;
static const int ONLYDIR = 0x01000000;
static const int DONT_FOLLOW = 0x02000000;
static const int EXCL_UNLINK = 0x04000000;
static const int MASK_ADD = 0x20000000;
static const int ISDIR = 0x40000000;
static const int ONESHOT = 0x80000000;
}]],
MAP = ffi.new[[struct {
static const int ANONYMOUS = 0x20;
}]],
}
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["posix"]=(function()
local ffi = require("ffi")
local C = ffi.C

local bit = require("bit")
local string = require("string")

local class = require("class").class
local error_util = require("error_util")

require("posix_types")
local decls = require("posix_decls")
local linux_decls = require("ljclang_linux_decls")

local assert = assert
local check = error_util.check
local checktype = error_util.checktype
local error = error
local ipairs = ipairs
local tostring = tostring
local type = type

----------

ffi.cdef[[
void free(void *ptr);

ssize_t read(int, void *, size_t);
ssize_t write(int, const void *, size_t);
int open(const char *pathname, int flags);
int close(int);
int dup2(int oldfd, int newfd);
int fcntl(int fildes, int cmd, ...);

void *mmap(void *addr, size_t length, int prot, int flags,
           int fd, off_t offset);
int munmap(void *addr, size_t length);

char *strerror(int);
long sysconf(int name);

pid_t fork(void);
pid_t getpid(void);
pid_t waitpid(pid_t pid, int *stat_loc, int options);
uid_t geteuid(void);
int execv(const char *path, char *const argv[]);
int pipe(int pipefd[2]);

struct _IO_FILE;
typedef struct _IO_FILE FILE;
FILE *stdin, *stdout, *stderr;
FILE *freopen(const char *pathname, const char *mode, FILE *stream);
char *realpath(const char *path, char *resolved_path);
]]

-- NOTE: readdir64() is present in glibc and musl. We use it instead of readdir() because
--  with glibc, 'struct dirent' has #ifndef-conditional member definitions while 'struct
--  dirent64' does not.
--
--  In musl, 'dirent64' is simply #defined to 'dirent'. In Alpine Linux's /usr/lib/libc.a,
--  'dirent64' is present as 'W' symbol as shown by 'nm'.
ffi.cdef[[
struct _DIR;
struct dirent64;
typedef struct _DIR DIR;
DIR *opendir(const char *name);
int closedir(DIR *dirp);
struct dirent64 *readdir64(DIR *dirp);
]]

-- NOTE: leave type 'struct sockaddr' incomplete.
ffi.cdef[[
struct sockaddr;
int socket(int domain, int type, int protocol);
int bind(int socket, const struct sockaddr *address, socklen_t address_len);
int connect(int socket, const struct sockaddr *address, socklen_t address_len);
int listen(int socket, int backlog);
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int shutdown(int sockfd, int how);
]]

ffi.cdef[[
int clock_gettime(clockid_t clock_id, struct timespec *tp);
int clock_nanosleep(clockid_t clock_id, int flags,
                    const struct timespec *request,
                    struct timespec *remain);

int poll(struct pollfd fds[], nfds_t nfds, int timeout);

int sigaddset(sigset_t *, int);
int sigemptyset(sigset_t *);
int sigprocmask(int, const sigset_t *restrict, sigset_t *restrict);

typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
]]

local pollfd_t = ffi.typeof("struct pollfd")
local pollfd_array_t = ffi.typeof("$ [?]", pollfd_t)

ffi.cdef[[
int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
]]

local uint32_t = ffi.typeof("uint32_t")

local fd_set_t = ffi.typeof("fd_set")
-- We just assume that fd_set is made up of fd_mask in sequence handled as "bit array".
-- See
--  - glibc on Ubuntu/Raspbian: /usr/include/<triple>/bits/select.h
--  - musl on Alpine: /usr/include/sys/select.h
local fd_mask_t = ffi.typeof(
    ({ [4] = uint32_t, [8] = "uint64_t" })[ffi.alignof(fd_set_t)]
)
assert(fd_set_t{{-1}}.v_[0] == fd_mask_t(-1), "inconsistent fd_mask")

local FD_SETSIZE = 8 * ffi.sizeof(fd_set_t)
local FD_MASK_BIT_COUNT = 8 * ffi.sizeof(fd_mask_t)

local function checkSetFd(fd)
    checktype(fd, 1, "number", 4)
    check(fd >= 0 and fd < FD_SETSIZE, "file descriptor value is too large", 3)
end

fd_set_t = class
{
    fd_set_t,

    set = function(self, fd)
        local maskIdx, theBit = self:maskIdxAndBit(fd)
        self.v_[maskIdx] = bit.bor(self.v_[maskIdx], theBit)
    end,

    clear = function(self, fd)
        local maskIdx, theBit = self:maskIdxAndBit(fd)
        self.v_[maskIdx] = bit.band(self.v_[maskIdx], bit.bnot(theBit))
    end,

    isSet = function(self, fd)
        local maskIdx, theBit = self:maskIdxAndBit(fd)
        return (bit.band(self.v_[maskIdx], theBit) ~= 0)
    end,

-- private:
    maskIdxAndBit = function(self, fd)
        checkSetFd(fd)
        local maskIdx = uint32_t(fd / FD_MASK_BIT_COUNT)
        local theBit = bit.lshift(1ULL, fd % FD_MASK_BIT_COUNT)
        return maskIdx, theBit
    end
}

local SIG = decls.SIG

local external_SIG = {
    INT = SIG.INT,
    -- NOTE: that SIG_DFL == NULL has been checked in posix_decls.lua
    DFL = ffi.new("sighandler_t"),
}

local external_E = {
    NODEV = decls.E.NODEV,
}

local api = {
    AF = decls.AF,
    E = external_E,
    O = decls.O,
    MAP = decls.MAP,
    POLL = decls.POLL,
    PROT = decls.PROT,
    _SC = decls._SC,
    SHUT = decls.SHUT,
    SIG = external_SIG,
    SOCK = decls.SOCK,

    fd_set_t = fd_set_t,
}

local function getErrnoString()
    local errno = ffi.errno()
    local errmsgCStr = C.strerror(errno)
    local errMsg = (errmsgCStr ~= nil) and " "..ffi.string(errmsgCStr) or ""
    return ("[E%s]%s"):format(tostring(errno), errMsg)
end

api.getErrnoString = getErrnoString

local function call(functionName, ...)
    local ret = C[functionName](...)

    if (ret < 0) then
        local message = string.format("%s failed: %s", functionName, getErrnoString())
        error(message)
    end

    return ret
end

local function callAllowing(isErrnoAllowed, functionName, ...)
    local ret = C[functionName](...)
    local errno = (ret < 0) and ffi.errno() or nil

    if (ret < 0 and not isErrnoAllowed[errno]) then
        local message = string.format("%s failed: %s", functionName, getErrnoString())
        error(message)
    end

    return ret, errno
end

local char_array_t = ffi.typeof("char [?]")
local char_ptr_array_t = ffi.typeof("char * [?]")

local function makeArgv(tab)
    assert(tab[0] ~= nil)

    local argc = #tab + 1
    local charArrays = {}

    for i = 0, argc - 1 do
        local str = tab[i]
        check(type(str) == "string", "table values must be strings", 3)

        local charArray = char_array_t(#str + 1, str)
        assert(charArray[#str] == 0)
        charArrays[i] = charArray
    end

    local argv = char_ptr_array_t(argc + 1, charArrays)
    argv[argc] = nil
    return argv
end

----------

do
    -- Block SIGPIPE so that the writes to pipes with no one to read it (possible only by
    -- application logic error) return, the EPIPE errno is seen, and we throw a Lua error.
    --
    -- TODO: think about whether to keep here of move elsewhere.
    local sigset = ffi.new("sigset_t [1]")
    call("sigemptyset", sigset)
    call("sigaddset", sigset, SIG.PIPE)
    call("sigprocmask", SIG.BLOCK, sigset, nil)
end

local uint8_ptr_t = ffi.typeof("uint8_t *")
local uint8_array_t = ffi.typeof("uint8_t [?]")
local Allow_EAGAIN = { [decls.E.AGAIN] = true }
local Allow_EPIPE = { [decls.E.PIPE] = true }

api.STDOUT_FILENO = 1
api.STDERR_FILENO = 2

api.Fd = class
{
    function(fd)
        checktype(fd, 1, "number", 2)

        return {
            fd = fd,
        }
    end,

    read = function(self, byteCount)
        checktype(byteCount, 1, "number", 2)
        check(byteCount >= 1, "argument must be at least 1", 2)
        local buf = uint8_array_t(byteCount)
        local bytesRead = call("read", self.fd, buf, byteCount)
        assert(bytesRead <= byteCount)
        return ffi.string(buf, bytesRead)
    end,

    -- Read from a file descriptor previously opened with O_NONBLOCK.
    readNonblocking = function(self, byteCount)
        checktype(byteCount, 1, "number", 2)
        check(byteCount >= 1, "argument must be at least 1", 2)
        local buf = uint8_array_t(byteCount)
        local bytesRead, errno = callAllowing(Allow_EAGAIN, "read", self.fd, buf, byteCount)
        assert(bytesRead <= byteCount)
        return (errno == nil) and ffi.string(buf, bytesRead) or nil
    end,

    readInto = function(self, obj, allowPartial)
        return self:_readIntoCommon(obj, allowPartial, call)
    end,

    readIntoAllowing = function(self, obj, allowPartial, errnoAllowTab)
        checktype(errnoAllowTab, 3, "table", 4)

        return self:_readIntoCommon(obj, allowPartial, function(...)
            return callAllowing(errnoAllowTab, ...)
        end)
    end,

    _readIntoCommon = function(self, obj, allowPartial, _callFunc)  -- private
        checktype(obj, 1, "cdata", 3)
        checktype(allowPartial, 2, "boolean", 3)

        local length = ffi.sizeof(obj)
        check(length ~= nil, "argument #1 must have ffi.sizeof() ~= nil", 3)
        check(length >= 1, "argument #1 must have ffi.sizeof() >= 1", 3)

        local bytePtr = ffi.cast(uint8_ptr_t, obj)
        local bytesRead = 0

        repeat
            local remainByteCount = length - bytesRead
            local ret = _callFunc("read", self.fd, bytePtr, remainByteCount)
            if (ret == -1) then
                assert(_callFunc ~= call)
                return nil
            end

            assert(ret >= 0 and ret <= remainByteCount)
            bytePtr = bytePtr + ret
            bytesRead = bytesRead + ret
        until (allowPartial or bytesRead == length)

        return obj, bytesRead
    end,

    write = function(self, obj)
        check(type(obj) == "string" or type(obj) == "cdata",
              "argument #1 must be a string or cdata", 2)
        local length = (type(obj) == "string") and #obj or ffi.sizeof(obj)
        check(length > 0, "argument must have non-zero length", 2)
        local bytesWritten = call("write", self.fd, obj, length)
        assert(bytesWritten <= length)
        -- TODO: check non-discarding at all usage sites.
        return bytesWritten
    end,

    writeFull = function(self, obj, length)
        check(type(obj) == "cdata",
              "argument #1 must be a cdata", 2)
        check(length == nil or type(length) == "number",
              "argument #2 must be nil or a number", 2)

        local objLength = ffi.sizeof(obj)
        local writeLength = (length ~= nil) and length or objLength

        check(writeLength > 0, "must request to write at least one byte", 2)
        check(writeLength <= objLength, "requested write length greater than object size", 2)

        local bytePtr = ffi.cast(uint8_ptr_t, obj)
        local bytesWritten = 0

        repeat
            local remainByteCount = writeLength - bytesWritten
            local ret = call("write", self.fd, bytePtr, remainByteCount)
            assert(ret >= 0 and ret <= remainByteCount)
            bytePtr = bytePtr + ret
            bytesWritten = bytesWritten + ret
        until (bytesWritten == writeLength)
    end,

    -- Write to a file descriptor, catching EPIPE instead of propagating it as Lua error.
    writePipe = function(self, obj)
        check(type(obj) == "string" or type(obj) == "cdata",
              "argument #1 must be a string or cdata", 2)
        local length = (type(obj) == "string") and #obj or ffi.sizeof(obj)
        check(length > 0, "argument must have non-zero length", 2)
        local bytesWritten, errno = callAllowing(Allow_EPIPE, "write", self.fd, obj, length)
        assert(bytesWritten <= length)
        return (errno == nil) and bytesWritten or nil
    end,

    -- Redirect 'fd' to us.
    capture = function(self, fd)
        checktype(fd, 1, "number", 2)
        local ret = call("dup2", self.fd, fd)
        assert(ret == fd)
        return ret
    end,

    shutdown = function(self, how)
        local ret = call("shutdown", self.fd, how)
    end,

    close = function(self)
        local ret = call("close", self.fd)
        self.fd = -1
        assert(ret == 0)
        return ret
    end,
--[[
-- TODO: implement
    __gc = function(self)
        return self:close()
    end,
--]]
}

local Directory = class{
    "DIR *ptr;",

    read = function(self)
        assert(self.ptr ~= nil)

        ffi.errno(0)
        local dirEnt = C.readdir64(self.ptr)
        if (ffi.errno() ~= 0) then
            error("readdir failed: %s"..getErrnoString())
        end

        return (dirEnt ~= nil) and ffi.string(decls.getDirent64Name(dirEnt)) or nil
    end
}

api.Dir = function(name)
    checktype(name, 1, "string", 2)

    local dirPtr = C.opendir(name)
    if (dirPtr == nil) then
        error("opendir failed: %s"..getErrnoString())
    end

    return ffi.gc(Directory(dirPtr), function(d)
        C.closedir(d.ptr)
    end)
end

local timespec_t = ffi.typeof("struct timespec")
local single_timespec_t = ffi.typeof("$ [1]", timespec_t)

-- TODO: for the clock_* functions:
--  - expose more or all arguments
--  - more proper argument and/or return value checking

api.clock_gettime = function()
    local ts = single_timespec_t()
    local ret = call("clock_gettime", decls.CLOCK.MONOTONIC, ts)
    assert(ret == 0)
    return ts[0]
end

api.clock_nanosleep = function(nsec)
    local request = timespec_t(nsec / 1e9, nsec % 1e9)
    local ret = call("clock_nanosleep", decls.CLOCK.MONOTONIC, 0, request, nil)
    assert(ret == 0)
end

api.sysconf = function(name)
    checktype(name, 2, "number", 2)
    local ret = call("sysconf", name)
    assert(ret ~= -1)
    return ret
end

api.poll = function(tab, timeoutMs)
    checktype(tab, 1, "table", 2)
    check(#tab > 0, "passed table must not be empty", 2)
    check(timeoutMs == nil or type(timeoutMs) == "number",
          "argument #2 must be nil or a number", 2)

    local homogenousEventSet = (tab.events ~= nil) and tab.events or nil
    assert(homogenousEventSet ~= nil, "must provide <tab>.events: "..
               "inhomogenous event specification not implemented")

    local pollfds = pollfd_array_t(#tab, pollfd_t{0, tab.events, 0})

    for i, fd in ipairs(tab) do
        check(type(fd) == "number", "numeric elements of passed table must be numbers", 2)
        pollfds[i - 1].fd = fd
    end

    local eventCount = call("poll", pollfds, #tab, timeoutMs or -1)
    assert(eventCount >= 0)

    local events = {}

    for i = 0, #tab - 1 do
        if (pollfds[i].revents ~= 0) then
            local p = pollfds[i]
            events[#events + 1] = pollfd_t(p)
        end
    end

    assert(#events == eventCount)
    return events
end

-- NOTE: Linux's "man mmap" explicitly mentions this value.
local MAP_FAILED = ffi.cast("void *", -1)

api.mmap = function(addr, length, prot, flags, fd, offset)
    check(addr == nil, "argument #1 must be nil", 2)

    checktype(length, 2, "number", 2)
    check(length > 0, "argument #2 must be greater than zero", 2)

    checktype(prot, 3, "number", 2)
    checktype(flags, 4, "number", 2)

    do
        local MAP, PROT = decls.MAP, decls.PROT
        check(bit.band(prot, bit.bnot(PROT.READ + PROT.WRITE)) == 0,
              "Only PROT.READ and/or PROT.WRITE allowed", 2)
        local allowedFlags = bit.bnot(MAP.SHARED + MAP.PRIVATE + linux_decls.MAP.ANONYMOUS)
        check(bit.band(flags, allowedFlags) == 0,
              "Only MAP.{SHARED,PRIVATE,ANONYMOUS} allowed", 2)
        check(bit.band(flags, linux_decls.MAP.ANONYMOUS) == 0 or fd == -1,
              "argument #5 must be -1 when argument #4 has MAP.ANONYMOUS set", 2)
    end

    checktype(fd, 5, "number", 2)
    checktype(offset, 6, "number", 2)

    local ptr = C.mmap(addr, length, prot, flags, fd, offset)
    if (ptr == MAP_FAILED) then
        error("mmap failed: "..getErrnoString())
    end

    return ffi.gc(ptr, function(p)
        C.munmap(p, length)
    end)
end

api.fork = function()
    local ret = call("fork")
    assert(ret >= 0)

    if (ret == 0) then
        return "child", nil
    else
        return "parent", ret
    end
end

-- Example: "/bin/ls", { "-la" }
api.exec = function(fileName, args)
    checktype(fileName, 1, "string", 2)
    check(#fileName > 0 and fileName:sub(1,1) == '/',
          "argument #1 must be an absolute file name", 2)
    checktype(args, 2, "table", 2)
    check(args[0] == nil, "argument #2 must not contain an entry at index 0", 2)

    args[0] = fileName

    local argv = makeArgv(args)
    call("execv", argv[0], argv)
    assert(false)
end

api.freopen = function(pathname, mode, stream)
    checktype(pathname, 1, "string", 2)
    checktype(mode, 2, "string", 2)

    check(ffi.istype("FILE *", stream), "argument #3 must be a FILE *", 2)
    check(stream ~= nil, "argument #3 must be non-NULL")

    local retPtr = C.freopen(pathname, mode, stream)

    if (retPtr == nil) then
        local message = string.format("freopen failed: %s", getErrnoString())
        error(message)
    end
end

api.realpath = function(pathname)
    checktype(pathname, 1, "string", 2)

    local retPtr = C.realpath(pathname, nil)

    if (retPtr == nil) then
        return nil, getErrnoString()
    end

    local str = ffi.string(retPtr)
    C.free(retPtr)
    return str
end

local pid_t = ffi.typeof("pid_t")

local function isPid(v)
    return (type(v) == "number" or ffi.istype("pid_t", v))
end

api.waitpid = function(pid, options)
    check(isPid(pid), "argument #1 must be a pid", 2)
    -- Exclude other conventions other than passing -1 or an exact PID:
    check(pid == -1 or pid > 0, "argument #1 must be -1 or strictly positive", 2)
    checktype(options, 2, "number", 2)
    check(options == 0, "argument #2 must be 0 (not yet implemented)", 2)

    local stat_loc = ffi.new("int [1]")
    local ret_pid = call("waitpid", pid, stat_loc, options)
    assert(pid == -1 or ret_pid == pid)

    if (stat_loc[0] == 0) then
        return "exited", 0, ret_pid
    end

    -- Any other condition than exiting with status 0: not implemented.
    -- (We would have to have the W*() macros from sys/wait.h here somehow.)
    return "NYI", -1, pid_t(-1)
end

api.pipe = function()
    local fds = ffi.new("int [2]")
    local ret = call("pipe", fds)
    assert(ret == 0)

    return {
        r = api.Fd(fds[0]),
        w = api.Fd(fds[1]),
    }
end

api.signal = function(sig, handler)
    check(sig == SIG.INT, "argument #1 must be SIG.INT", 2)
    check(handler == external_SIG.DFL, "argument #2 must be SIG.DFL", 2)

    ffi.errno(0)
    C.signal(sig, handler)
    assert(ffi.errno() == 0, "signal() failed unexpectedly")
end

-- Done!
return api
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["inet"]=(function()

local ffi = require("ffi")
local C = ffi.C

local bit = require("bit")

local class = require("class").class
local error_util = require("error_util")
local posix = require("posix")
local posix_decls = require("posix_decls")

local check = error_util.check
local checktype = error_util.checktype

local assert = assert
local error = error
local unpack = unpack

----------

local api = {}

-- Notes:
--  * In the real 'struct sockaddr_in', <port> and <address> are integers that are expected
--    in network byte order.
--  * The value '14' is from 'man 2 bind'.
local SockAddrInet = ffi.typeof[[
struct {
    sa_family_t family;
    uint8_t port[2];
    uint8_t address[4];

    uint8_t padding_[14 - 6];
} __attribute__((aligned(4)))
]]

local const_sockaddr_ptr_t = ffi.typeof("const struct sockaddr *")

local function cast(sockAddr)
    assert(ffi.istype(SockAddrInet, sockAddr))
    return ffi.cast(const_sockaddr_ptr_t, sockAddr)
end

local function SocketAddress(addrAndPort)
    checktype(addrAndPort, 1, "table", 2)
    check(#addrAndPort == 5, "argument #1 must have length 5", 2)

    local port = addrAndPort[5]
    local quad = { unpack(addrAndPort, 1, 4) }

    local portBytes = {
        bit.rshift(bit.band(port, 0xff00), 8),
        bit.band(port, 0xff)
    }

    return SockAddrInet(posix.AF.INET, portBytes, quad)
end

local AF = posix.AF
local SOCK = posix.SOCK

api.Socket = class
{
    function()
        local fd = C.socket(AF.INET, SOCK.STREAM, 0)

        if (fd < 0) then
            error("Failed creating socket: "..posix.getErrnoString())
        end

        return {
            -- NOTE: closed only from posix.Fd via one of the two connection paths.
            fd = fd
        }
    end,

    initiateConnection = function(self, addrAndPort)
        local sockAddr = SocketAddress(addrAndPort)
        local ret = C.connect(self.fd, cast(sockAddr), ffi.sizeof(sockAddr))

        if (ret < 0) then
            return nil, posix.getErrnoString()
        end

        return posix.Fd(self.fd)
    end,

    expectConnection = function(self, port, timeoutMs, beforeFirstAccept)
        local E, F, POLL, O = posix_decls.E, posix_decls.F, posix.POLL, posix.O

        -- From /usr/include/netinet/in.h:
        -- /* Address to accept any incoming messages.  */
        -- #define INADDR_ANY ((in_addr_t) 0x00000000)
        local bindAddr = SocketAddress{0,0,0,0; port}

        if (C.bind(self.fd, cast(bindAddr), ffi.sizeof(bindAddr)) < 0) then
            return nil, "bind failed: "..posix.getErrnoString()
        end

        if (C.listen(self.fd, 1) < 0) then
            return nil, "listen failed: "..posix.getErrnoString()
        end

        if (timeoutMs ~= nil) then
            local flags = C.fcntl(self.fd, F.GETFL)
            if (flags == -1) then
                return nil, "fcntl (F_GETFL) failed: "..posix.getErrnoString()
            end
            local newFlags = ffi.cast('int', bit.bor(flags, O.NONBLOCK))
            local ret = C.fcntl(self.fd, F.SETFL, newFlags)
            if (ret == -1) then
                return nil, "fcntl (F_SETFL) failed: "..posix.getErrnoString()
            end
        end

        local shouldWaitOnce = (timeoutMs ~= nil)
        local newFd

        for trial = 1, (shouldWaitOnce and 2 or 1) do
            if (trial == 1 and beforeFirstAccept ~= nil) then
                beforeFirstAccept()
            end

            newFd = C.accept(self.fd, nil, nil)

            if (newFd == -1) then
                if (shouldWaitOnce and trial == 1 and ffi.errno() == E.AGAIN) then
                    posix.poll({ events=POLL.IN, self.fd }, timeoutMs)
                else
                    return nil, "accept failed: "..posix.getErrnoString()
                end
            end
        end

        local ret = C.close(self.fd)
        -- If the file descriptor were invalid, we'd expect the functions above to fail.
        assert(ret >= 0)

        return posix.Fd(newFd)
    end,
}

-- Done!
return api
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["linux_decls"]=(function()
local ffi=require"ffi"
ffi.cdef[[
struct fb_fix_screeninfo {
	char id[16];			/* identification string eg "TT Builtin" */
	unsigned long smem_start;	/* Start of frame buffer mem */
					/* (physical address) */
	uint32_t smem_len;			/* Length of frame buffer mem */
	uint32_t type;			/* see FB_TYPE_*		*/
	uint32_t type_aux;			/* Interleave for interleaved Planes */
	uint32_t visual;			/* see FB_VISUAL_*		*/ 
	uint16_t xpanstep;			/* zero if no hardware panning  */
	uint16_t ypanstep;			/* zero if no hardware panning  */
	uint16_t ywrapstep;		/* zero if no hardware ywrap    */
	uint32_t line_length;		/* length of a line in bytes    */
	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
					/* (physical address) */
	uint32_t mmio_len;			/* Length of Memory Mapped I/O  */
	uint32_t accel;			/* Indicate to driver which	*/
					/*  specific chip/card we have	*/
	uint16_t capabilities;		/* see FB_CAP_*			*/
	uint16_t reserved[2];		/* Reserved for future compatibility */
};
struct fb_bitfield {
	uint32_t offset;			/* beginning of bitfield	*/
	uint32_t length;			/* length of bitfield		*/
	uint32_t msb_right;		/* != 0 : Most significant bit is */ 
					/* right */ 
};
struct fb_var_screeninfo {
	uint32_t xres;			/* visible resolution		*/
	uint32_t yres;
	uint32_t xres_virtual;		/* virtual resolution		*/
	uint32_t yres_virtual;
	uint32_t xoffset;			/* offset from virtual to visible */
	uint32_t yoffset;			/* resolution			*/

	uint32_t bits_per_pixel;		/* guess what			*/
	uint32_t grayscale;		/* 0 = color, 1 = grayscale,	*/
					/* >1 = FOURCC			*/
	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
	struct fb_bitfield green;	/* else only length is significant */
	struct fb_bitfield blue;
	struct fb_bitfield transp;	/* transparency			*/	

	uint32_t nonstd;			/* != 0 Non standard pixel format */

	uint32_t activate;			/* see FB_ACTIVATE_*		*/

	uint32_t height;			/* height of picture in mm    */
	uint32_t width;			/* width of picture in mm     */

	uint32_t accel_flags;		/* (OBSOLETE) see fb_info.flags */

	/* Timing: All values in pixclocks, except pixclock (of course) */
	uint32_t pixclock;			/* pixel clock in ps (pico seconds) */
	uint32_t left_margin;		/* time from sync to picture	*/
	uint32_t right_margin;		/* time from picture to sync	*/
	uint32_t upper_margin;		/* time from sync to picture	*/
	uint32_t lower_margin;
	uint32_t hsync_len;		/* length of horizontal sync	*/
	uint32_t vsync_len;		/* length of vertical sync	*/
	uint32_t sync;			/* see FB_SYNC_*		*/
	uint32_t vmode;			/* see FB_VMODE_*		*/
	uint32_t rotate;			/* angle we rotate counter clockwise */
	uint32_t colorspace;		/* colorspace for FOURCC-based modes */
	uint32_t reserved[4];		/* Reserved for future compatibility */
};
]]
return { FBIO = ffi.new[[struct {
static const int GET_VSCREENINFO = 0x4600;
static const int PUT_VSCREENINFO = 0x4601;
static const int GET_FSCREENINFO = 0x4602;
}]],
EV = ffi.new[[struct {
static const int SYN = 0x00;
static const int KEY = 0x01;
static const int REL = 0x02;
static const int ABS = 0x03;
static const int MSC = 0x04;
static const int SW = 0x05;
static const int LED = 0x11;
static const int SND = 0x12;
static const int REP = 0x14;
static const int FF = 0x15;
static const int PWR = 0x16;
static const int FF_STATUS = 0x17;
static const int MAX = 0x1f;
static const int VERSION = 0x010001;
}]],
ABS = ffi.new[[struct {
static const int MT_SLOT = 0x2f;
static const int MT_TOUCH_MAJOR = 0x30;
static const int MT_TOUCH_MINOR = 0x31;
static const int MT_WIDTH_MAJOR = 0x32;
static const int MT_WIDTH_MINOR = 0x33;
static const int MT_ORIENTATION = 0x34;
static const int MT_POSITION_X = 0x35;
static const int MT_POSITION_Y = 0x36;
static const int MT_TOOL_TYPE = 0x37;
static const int MT_BLOB_ID = 0x38;
static const int MT_TRACKING_ID = 0x39;
static const int MT_PRESSURE = 0x3a;
static const int MT_DISTANCE = 0x3b;
static const int MT_TOOL_X = 0x3c;
static const int MT_TOOL_Y = 0x3d;
}]],
FB_TYPE = ffi.new[[struct {
static const int PACKED_PIXELS = 0;
static const int PLANES = 1;
static const int INTERLEAVED_PLANES = 2;
static const int TEXT = 3;
static const int VGA_PLANES = 4;
static const int FOURCC = 5;
}]],
FB_VISUAL = ffi.new[[struct {
static const int MONO01 = 0;
static const int MONO10 = 1;
static const int TRUECOLOR = 2;
static const int PSEUDOCOLOR = 3;
static const int DIRECTCOLOR = 4;
static const int STATIC_PSEUDOCOLOR = 5;
static const int FOURCC = 6;
}]],
}
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["framebuffer"]=(function()
local ffi = require("ffi")
local C = ffi.C

local bit = require("bit")

local class = require("class").class
local error_util = require("error_util")
local linux_decls = require("linux_decls")
local posix = require("posix")

local check = error_util.check
local checktype = error_util.checktype

local FBIO = linux_decls.FBIO
local MAP = posix.MAP
local O = posix.O
local PROT = posix.PROT
local FB_TYPE = linux_decls.FB_TYPE
local FB_VISUAL = linux_decls.FB_VISUAL

local assert = assert
local error = error
local unpack = unpack

----------

local fb_fix_screeninfo = ffi.typeof("struct fb_fix_screeninfo")
local fb_var_screeninfo = ffi.typeof("struct fb_var_screeninfo")

ffi.cdef[[
int ioctl(int fd, unsigned long request, ...);
]]

local function ioctl(fd, request, arg)
    -- NOTE: will error if 'arg' present and not convertible to pointer.
    local ptr = (arg ~= nil) and ffi.new("void *", arg) or nil
    local vargs = { ptr }

    local res = C.ioctl(fd, request, unpack(vargs))

    if (res == -1) then
        return nil, posix.getErrnoString()
    end

    -- NOTE: 'res' discarded (currently no use).
    return arg
end

----------

local api = {
    ioctl = ioctl,
}

local function GetPixelTypes(bitsPerPixel)
    local intTypeStr = "uint"..bitsPerPixel.."_t"
    return ffi.typeof(intTypeStr), ffi.typeof("const "..intTypeStr)
end

local function GetOffsets(vi)
    check(vi.red.msb_right == 0 and vi.green.msb_right == 0 and vi.blue.msb_right == 0,
          "Most-significant-bit-is-right unsupported", 5)

    return vi.red.offset, vi.green.offset, vi.blue.offset
end

local function GetLengths(vi)
    return vi.red.length, vi.green.length, vi.blue.length
end

local function ExtractComponent(px, off, len)
    assert(off >= 0)
    assert(len >= 1)
    local mask = bit.lshift(1, len) - 1
    return bit.band(bit.rshift(px, off), mask)
end

local function GetUnpackPixelFunc(vi)
    local oR, oG, oB  = GetOffsets(vi)
    local lR, lG, lB  = GetLengths(vi)

    return function(px)
        return
            ExtractComponent(px, oR, lR),
            ExtractComponent(px, oG, lG),
            ExtractComponent(px, oB, lB),
            0
    end
end

local Mapping = class
{
    function(fb)
        local vinfo = fb:getVarInfo()
        check(fb.type == FB_TYPE.PACKED_PIXELS, "Only packed pixels supported", 3)
        check(fb.visual == FB_VISUAL.TRUECOLOR, "Only truecolor supported", 3)

        check(vinfo.xoffset == 0 and vinfo.yoffset == 0,
              "Only offset-less format supported", 2)
        assert(vinfo.xres <= vinfo.xres_virtual and vinfo.yres <= vinfo.yres_virtual)

        -- NOTE: this will error if there is no uint<BPP>_t type.
        local pixelType, constPxType = GetPixelTypes(vinfo.bits_per_pixel)
        local pixelPtrType = ffi.typeof("$ *", fb.writable and pixelType or constPxType)
        local pixelArrayType = ffi.typeof("$ [?]", pixelType)

        local fbSize = fb.line_length * vinfo.yres_virtual
        check(fbSize > 0, "INTERNAL ERROR: framebuffer has size zero", 1)
        local voidPtr = posix.mmap(
            nil, fbSize,
            PROT.READ + (fb.writable and PROT.WRITE or 0),
            fb.writable and MAP.SHARED or MAP.PRIVATE,
            fb.fd, 0)

        local pixelSize = vinfo.bits_per_pixel / 8
        assert(fb.line_length == pixelSize * vinfo.xres_virtual)

        return {
            -- Anchor mmap()ed memory (which will unmap on garbage collection).
            voidPtr_ = voidPtr,

            ptr = pixelPtrType(voidPtr),
            pxType = pixelType,
            pxSize = pixelSize,
            pxPtrType = pixelPtrType,
            pxArrayType = pixelArrayType,
            unpackPxFunc = GetUnpackPixelFunc(vinfo),

            xres_virtual = vinfo.xres_virtual,

            -- public:
            xres = vinfo.xres,
            yres = vinfo.yres,
        }
    end,

    -- CAUTION!
    getBasePointer = function(self)
        return self.ptr
    end,

    getLinearIndex = function(self, x, y)
        self:checkCoords(x, y)
        return self.xres_virtual * y + x
    end,

    getPixelPointer = function(self, x, y)
        return self.ptr + self:getLinearIndex(x, y)
    end,

    getPixelSize = function(self)
        return self.pxSize
    end,

    getPixelType = function(self)
        return self.pxType
    end,

    getRawSize = function(self)
        return self.xres_virtual * self.yres
    end,

    --== Reading

    getUnpackPixelFunc = function(self)
        return self.unpackPxFunc
    end,

    readRect = function(self, xb, yb, xlen, ylen)
        self:checkRect(xb, yb, xlen, ylen)

        local destArray = self.pxArrayType(xlen * ylen)

        for i = 0, ylen - 1 do
            local srcPtr = self:getPixelPointer(xb, yb + i)
            local destPtr = destArray + i * xlen
            ffi.copy(destPtr, srcPtr, xlen * self:getPixelSize())
        end

        return destArray
    end,

    --== Writing

    -- CAUTION: no bounds check for 'srcPtr'!
    writeRect = function(self, xb, yb, xlen, ylen, srcPtr)
        self:checkRect(xb, yb, xlen, ylen)
        -- Check that pointer type matches.
        self.pxPtrType(srcPtr)

        local lineByteCount = xlen * self:getPixelSize()

        for i = 0, ylen - 1 do
            local destPtr = self:getPixelPointer(xb, yb + i)
            ffi.copy(destPtr, srcPtr + i * xlen, lineByteCount)
        end
    end,

    fill = function(self, xb, yb, xlen, ylen, pixValue)
        self:checkRect(xb, yb, xlen, ylen)
        checktype(pixValue, 5, "number", 2)

        for y = yb, yb + ylen - 1 do
            local ptr = self:getPixelPointer(xb, y)
            for x = 0, xlen - 1 do
                ptr[x] = pixValue
            end
        end
    end,

-- private:
    checkRect = function(self, xb, yb, xlen, ylen)
        self:checkCoords(xb, yb)
        check(xlen >= 1 and ylen >= 1, "must specify a non-empty rectangle", 3)
        self:checkCoords(xb + xlen - 1, yb + ylen - 1)
    end,

    checkCoords = function(self, x, y)
        assert(x >= 0 and x <= self.xres - 1, "x coordinate out of bounds")
        assert(y >= 0 and y <= self.yres - 1, "y coordinate out of bounds")
    end,
}

api.FrameBuffer = class
{
    function(fbIndex, writable)
        checktype(fbIndex, 1, "number", 2)
        checktype(writable, 2, "boolean", 2)

        local deviceFileName = "/dev/fb"..fbIndex
        local fd = C.open(deviceFileName, writable and O.RDWR or O.RDONLY)
        if (fd == -1) then
            error("Failed opening "..deviceFileName..": "..posix.getErrnoString())
        end

        local finfo, errMsg = ioctl(fd, FBIO.GET_FSCREENINFO, fb_fix_screeninfo())
        if (finfo == nil) then
            C.close(fd)
            error("Failed getting fixed framebuffer info: "..posix.getErrnoString())
        end

        return {
            fd = fd,
            writable = writable,

            type = finfo.type,
            visual = finfo.visual,
            line_length = finfo.line_length,
        }
    end,

    getVarInfo = function(self)
        local vinfo, errMsg = ioctl(self.fd, FBIO.GET_VSCREENINFO, fb_var_screeninfo())
        if (vinfo == nil) then
            error("Failed getting variable framebuffer info: "..posix.getErrnoString())
        end
        return vinfo
    end,

    getMapping = function(self)
        return Mapping(self)
    end,

    close = function(self)
        C.close(self.fd)
    end,
}

-- Done!
return api
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["util"]=(function()
local ffi = require("ffi")

local bit = require("bit")
local math = require("math")

local error_util = require("error_util")
local check = error_util.check
local checktype = error_util.checktype
local class = require("class").class

local assert = assert
local error = error
local ipairs = ipairs
local type = type
local unpack = unpack

----------

local api = {}

-- argstab = splitAtWhitespace(args)
function api.splitAtWhitespace(args)
    check(type(args) == "string", "<args> must be a string", 2)

    local argstab = {}
    -- Split delimited by whitespace.
    for str in args:gmatch("[^%s]+") do
        argstab[#argstab+1] = str
    end

    return argstab
end

-- Is <tab> a sequence of strings?
local function iscellstr(tab)
    for i=1,#tab do
        if (type(tab[i]) ~= "string") then
            return false
        end
    end

    -- We require this because in ARGS_FROM_TAB below, an index 0 would be
    -- interpreted as the starting index.
    return (tab[0] == nil)
end

function api.check_iftab_iscellstr(tab, name, level)
    if (type(tab)=="table") then
        if (not iscellstr(tab)) then
            error(name.." must be a string sequence when a table, with no element at [0]", level+1)
        end
    end
end

function api.checkOptionsArgAndGetDefault(opts, defaultValue)
    if (opts == nil) then
        opts = defaultValue;
    else
        check(type(opts)=="number" or type(opts)=="table",
              "argument #1 must be a number or a table", 3)
        api.check_iftab_iscellstr(opts, "<opts>", 3)
    end

    return opts
end

function api.handleTableOfOptionStrings(lib, prefix, opts)
    assert(type(prefix) == "string")

    if (type(opts)=="table") then
        local optflags = {}
        for i=1,#opts do
            optflags[i] = lib[prefix..opts[i]]  -- look up the enum
        end
        opts = (#opts > 0) and bit.bor(unpack(optflags)) or 0
    end

    return opts
end

function api.getCommonPrefix(getString, commonPrefix, ...)
    checktype(getString, 1, "function", 2)
    check(commonPrefix == nil or type(commonPrefix) == "string",
          "argument #2 must be nil or a string", 2)

    for key, value in ... do
        local str = getString(key, value)
        check(type(str) == "string", "getString(k, v) for iterated k, v should return a string", 2)

        if (commonPrefix == nil) then
            commonPrefix = str
        else
            for i = 1, math.min(#commonPrefix, #str) do
                if (commonPrefix:sub(1, i) ~= str:sub(1, i)) then
                    commonPrefix = commonPrefix:sub(1, i-1)
                end
            end
        end
    end

    return commonPrefix
end

function api.copySequence(tab)
    local newTab = {}

    for i = 1,#tab do
        newTab[i] = tab[i]
    end

    return newTab
end

---------- Bimap ----------

local BimapTags = {
    FIRST_TYPE = {},
    SECOND_TYPE = {},
    COUNT = {},
}

api.Bimap = class
{
    function(firstType, secondType)
        checktype(firstType, 1, "string", 2)
        checktype(secondType, 2, "string", 2)
        check(firstType ~= secondType, "arguments #1 and #2 must be distinct", 2)

        return {
            [BimapTags.FIRST_TYPE] = firstType,
            [BimapTags.SECOND_TYPE] = secondType,
            [BimapTags.COUNT] = 0,
        }
    end,

    -- NOTE: 'self' itself is used to store the data.
    -- Hence, the "member functions" are stand-alone.
}

function api.BimapAdd(self, first, second)
    checktype(first, 1, self[BimapTags.FIRST_TYPE], 2)
    checktype(second, 2, self[BimapTags.SECOND_TYPE], 2)

    -- NOTE: No checking of any kind (such as for one-to-oneness).
    self[first] = second
    self[second] = first

    self[BimapTags.COUNT] = self[BimapTags.COUNT] + 1
end

function api.MakeBimap(tab)
    checktype(tab, 1, "table", 2)

    local firstItem = tab[1]
    local bimap = api.Bimap(type(firstItem[1]), type(firstItem[2]))

    for _, item in ipairs(tab) do
        api.BimapAdd(bimap, item[1], item[2])
    end

    return bimap
end

function api.BimapGetCount(self)
    return self[BimapTags.COUNT]
end

---------- BoolArray ----------

local function CheckIsFiniteInt(number, argIdx)
    checktype(number, argIdx, "number", 3)
    check(number >= 1 and number < math.huge, "argument must be a finite number", 3)
    check(math.floor(number) == number, "argument must be an integral number", 3)
end

api.BoolArray = function(size, initialValue)
    CheckIsFiniteInt(size, 1)
    checktype(initialValue, 2, "boolean", 2)

    local array = {}
    for i = 1,size do
        array[i] = initialValue
    end
    return array
end

-- Done!
return api
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["input"]=(function()

local ffi = require("ffi")
local bit = require("bit")

local error_util = require("error_util")

local class = require("class").class
local ioctl = require("framebuffer").ioctl  -- TODO: pull out to separate file
local posix = require("posix")
local util = require("util")

local linux_decls = require("linux_decls")
local ABS = linux_decls.ABS
local EV = linux_decls.EV

local check = error_util.check
local checktype = error_util.checktype

local assert = assert
local error = error
local ipairs = ipairs
local tonumber = tonumber
local type = type

----------

-- From <linux/input.h> with __u16/__s32 -> uint16_t/int32_t etc. changes.
ffi.cdef[[
struct input_event {
    struct timeval time;
    uint16_t type;
    uint16_t code;
    int32_t value;
};

struct input_absinfo {
    int32_t value;
    int32_t minimum;
    int32_t maximum;
    int32_t fuzz;
    int32_t flat;
    int32_t resolution;
};

struct input_mask {
    uint32_t type;
    uint32_t codes_size;
    uint64_t codes_ptr;
};
]]

local input_event_t = class
{
    ffi.typeof("struct input_event"),

    getMs = function(self)
        -- TODO: ensure monotonic clock.
        return 1000 * tonumber(self.time.sec) + tonumber(self.time.usec) / 1000
    end,
}

local input_absinfo_t = ffi.typeof("struct input_absinfo")
local input_mask_t = ffi.typeof("struct input_mask")

-- IOCTL marcos in Lua.
-- See /usr/include/asm-generic/ioctl.h

local _IOC_BITS = {
    NR = 8,
    TYPE = 8,
    SIZE = 14,
    DIR = 2,
}

local _IOC_SHIFT = {
    NR = 0,
    TYPE = _IOC_BITS.NR,
    SIZE = _IOC_BITS.NR + _IOC_BITS.TYPE,
    DIR = _IOC_BITS.NR + _IOC_BITS.TYPE + _IOC_BITS.SIZE,
}

local function _IOC(dir, typ, nr, size)
    local shl = bit.lshift

    assert(type(typ) == "string" and #typ == 1)
    assert(type(nr) == "number" and nr >= 0 and nr < 2^_IOC_BITS.NR)

    return bit.bor(
        shl(dir, _IOC_SHIFT.DIR),
        shl(typ:byte(), _IOC_SHIFT.TYPE),
        shl(nr, _IOC_SHIFT.NR),
        shl(size, _IOC_SHIFT.SIZE))
end

local function _IOR(typ, nr, ctype)
    return _IOC(2, typ, nr, ffi.sizeof(ctype))
end

local function _IOW(typ, nr, ctype)
    return _IOC(1, typ, nr, ffi.sizeof(ctype))
end

-- <linux/event.h> ioctls

local device_name_buf_t = ffi.typeof("char [256]")

local EVIOCGNAME = _IOR('E', 0x06, device_name_buf_t)  -- get device name
local EVIOCGABS = {  -- get abs value/limits
    -- TODO: generalize to other ABS values?
    X = _IOR('E', 0x40 + ABS.MT_POSITION_X, input_absinfo_t),
    Y = _IOR('E', 0x40 + ABS.MT_POSITION_Y, input_absinfo_t),
}

local EVIOCSMASK =_IOW('E', 0x93, input_mask_t)  -- Set event-masks

local IoctlTypes = {
    [EVIOCGNAME] = device_name_buf_t,
    [EVIOCGABS.X] = input_absinfo_t,
    [EVIOCGABS.Y] = input_absinfo_t,

    [EVIOCSMASK] = function(typ, codesToSet)
        checktype(typ, 1, "number", 2)
        checktype(codesToSet, 2, "table", 2)

        local NumCodes = 256
        local bitMask = ffi.new("uint8_t [?]", NumCodes / 8)

        local shl, shr, band, bor = bit.lshift, bit.rshift, bit.band, bit.bor

        for _, code in ipairs(codesToSet) do
            check(type(code) == "number", "every value in argument #1 must be a number", 2)
            check(code >= 0 and code < NumCodes, "code value out of bounds", 2)

            bitMask[shr(code, 3)] = bor(bitMask[shr(code, 3)],
                                        shl(1, band(code, 7)))
        end

        local ptrAsInt = ffi.cast("uint64_t", bitMask)
        return input_mask_t(typ, ffi.sizeof(bitMask), ptrAsInt), bitMask
    end,
}

local Identity = function(object)
    return object
end

local IoctlReturn = {
    [EVIOCGNAME] = function(deviceNameBuf)
        deviceNameBuf[ffi.sizeof(deviceNameBuf) - 1] = 0
        return ffi.string(deviceNameBuf)
    end,

    [EVIOCGABS.X] = Identity,
    [EVIOCGABS.Y] = Identity,
}

----------

local api = {
    EV = EV,

    EVIOC = {
        GNAME = EVIOCGNAME,
        GABS = {
            X = EVIOCGABS.X,
            Y = EVIOCGABS.Y,
        },

        SMASK = EVIOCSMASK,
    },
}

-- Originally adapted from:
--  https://github.com/canselcik/libremarkable/wiki/Reading-Parade-TrueTouch-Gen5-Multitouch-Input
api.MultiTouchCode = util.MakeBimap
{
    { "POSX", ABS.MT_POSITION_X },
    { "POSY", ABS.MT_POSITION_Y },
    { "PRESSURE", ABS.MT_PRESSURE },
    { "TRACKING_ID", ABS.MT_TRACKING_ID },
    { "TOUCH_MAJOR", ABS.MT_TOUCH_MAJOR },
    { "TOUCH_MINOR", ABS.MT_TOUCH_MINOR },
    { "ORIENTATION", ABS.MT_ORIENTATION },
    { "TOOL_TYPE", ABS.MT_TOOL_TYPE },
    { "ABS_DISTANCE", ABS.MT_DISTANCE },
}

api.EventDevice = class
{
    function(device)
        check(type(device)  == "number" or type(device) == "string",
              "argument #1 must be a number or string", 2)
        local devFileName = (type(device) == "number") and
            ("/dev/input/event%d"):format(device) or
            device

        local fd = ffi.C.open(devFileName, posix.O.RDONLY)
        local errMsg = (fd == -1) and posix.getErrnoString() or nil

        return {
            fd = posix.Fd(fd),
            errMsg = errMsg,
        }
    end,

    getRawFd = function(self)
        return self.fd.fd
    end,

    close = function(self)
        self.fd:close()
    end,

    ioctl = function(self, request, ...)
        checktype(request, 1, "number", 2)
        local cType = IoctlTypes[request]
        check(cType ~= nil, "unsupported ioctl", 2)

        local data, anchor = cType(...)
        local ret, errMsg = ioctl(self.fd.fd, request, data)

        if (ret == nil) then
            return nil, errMsg
        end

        local finalizer = IoctlReturn[request]
        return (finalizer ~= nil) and finalizer(data) or nil
    end,

    readEvent = function(self)
        local event = input_event_t()
        return self.fd:readInto(event, false)
    end,
}

-- Done!
return api
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["jkiss_rng"]=(function()
-- Implementation of the JKISS random number generator from
-- http://www0.cs.ucl.ac.uk/staff/D.Jones/GoodPracticeRNG.pdf

local ffi = require("ffi")
assert(jit.version_num >= 20100,
       "Requires LuaJIT 2.1 for bit operations on 64-bit integers")

local bit = require("bit")

local class = require("class").class

local tonumber = tonumber

----------

local api = {}

local uint32_t = ffi.typeof("uint32_t")
local uint64_t = ffi.typeof("uint64_t")

api.JKissRng = class
{
    "uint32_t x, y, z, c;",

    __new = function(ct)
        return ffi.new(ct, 123456789, 987654321, 43219876, 654321)
    end,

    getu32 = function(self)
        self.x = 314527869 * self.x + 1234567

        self.y = bit.bxor(self.y, bit.lshift(self.y, 5))
        self.y = bit.bxor(self.y, bit.rshift(self.y, 7))
        self.y = bit.bxor(self.y, bit.lshift(self.y, 22))

        local t = 4294584393ULL * self.z + self.c
        -- NOTE: bit operations on 64-bit integers are a LuaJIT 2.1 feature,
        -- according to:
        --  https://github.com/Egor-Skriptunoff/pure_lua_SHA/blob/master/README.md
        self.c = bit.rshift(t, 32)
        self.z = t

        local sum = uint64_t(self.x) + self.y + self.z
        return tonumber(uint32_t(sum))
    end,

    getDouble = function(self)
        local hi = bit.rshift(self:getu32(), 6) -- 26 bits
        local lo = bit.rshift(self:getu32(), 5) -- 27 bits
        return (hi * 0x1p27 + lo) / 0x1p53
    end,
}

-- Done!
return api
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["remarkable_decls"]=(function()
local ffi=require"ffi"
ffi.cdef[[
typedef enum _eink_ioctl_command {
  MXCFB_SET_WAVEFORM_MODES	           = 0x40484600 | 0x2B, // takes struct mxcfb_waveform_modes
  MXCFB_SET_TEMPERATURE		             = 0x40484600 | 0x2C, // takes int32_t
  MXCFB_SET_AUTO_UPDATE_MODE           = 0x40484600 | 0x2D, // takes __u32
  MXCFB_SEND_UPDATE                    = 0x40484600 | 0x2E, // takes struct mxcfb_update_data
  MXCFB_WAIT_FOR_UPDATE_COMPLETE       = 0x40484600 | 0x2F, // takes struct mxcfb_update_marker_data
  MXCFB_SET_PWRDOWN_DELAY              = 0x40484600 | 0x30, // takes int32_t
  MXCFB_GET_PWRDOWN_DELAY              = 0x40484600 | 0x31, // takes int32_t
  MXCFB_SET_UPDATE_SCHEME              = 0x40484600 | 0x32, // takes __u32
  MXCFB_GET_WORK_BUFFER                = 0x40484600 | 0x34, // takes unsigned long
  MXCFB_SET_TEMP_AUTO_UPDATE_PERIOD    = 0x40484600 | 0x36, // takes int32_t
  MXCFB_DISABLE_EPDC_ACCESS            = 0x40484600 | 0x35,
  MXCFB_ENABLE_EPDC_ACCESS             = 0x40484600 | 0x36
} eink_ioctl_command;
]]
ffi.cdef[[
typedef enum _auto_update_mode {
  AUTO_UPDATE_MODE_REGION_MODE         = 0,
  AUTO_UPDATE_MODE_AUTOMATIC_MODE      = 1
} auto_update_mode;

typedef enum _update_scheme {
  UPDATE_SCHEME_SNAPSHOT         = 0,
  UPDATE_SCHEME_QUEUE            = 1,
  UPDATE_SCHEME_QUEUE_AND_MERGE  = 2
} update_scheme;

typedef enum _update_mode
{
  UPDATE_MODE_PARTIAL   = 0,
  UPDATE_MODE_FULL      = 1
} update_mode;

typedef enum _waveform_mode {
  WAVEFORM_MODE_INIT         = 0x0,	                 /* Screen goes to white (clears) */
  WAVEFORM_MODE_GLR16			   = 0x4,                  /* Basically A2 (so partial refresh shouldnt be possible here) */
  WAVEFORM_MODE_GLD16			   = 0x5,                  /* Official -- and enables Regal D Processing */

  // Unsupported?
  WAVEFORM_MODE_DU           = 0x1,	                 /* [Direct Update] Grey->white/grey->black  -- remarkable uses this for drawing */
  WAVEFORM_MODE_GC16         = 0x2,	                 /* High fidelity (flashing) */
  WAVEFORM_MODE_GC4          = WAVEFORM_MODE_GC16,   /* For compatibility */
  WAVEFORM_MODE_GC16_FAST    = 0x3,                  /* Medium fidelity  -- remarkable uses this for UI */
  WAVEFORM_MODE_GL16_FAST    = 0x6,                  /* Medium fidelity from white transition */
  WAVEFORM_MODE_DU4          = 0x7,	                 /* Medium fidelity 4 level of gray direct update */
  WAVEFORM_MODE_REAGL	       = 0x8,	                 /* Ghost compensation waveform */
  WAVEFORM_MODE_REAGLD       = 0x9,	                 /* Ghost compensation waveform with dithering */
  WAVEFORM_MODE_GL4		       = 0xA,	                 /* 2-bit from white transition */
  WAVEFORM_MODE_GL16_INV		 = 0xB,	                 /* High fidelity for black transition */
  WAVEFORM_MODE_AUTO			   = 257                   /* Official */
} waveform_mode;

typedef enum _display_temp {
  TEMP_USE_AMBIENT           = 0x1000,
  TEMP_USE_PAPYRUS           = 0X1001,
  TEMP_USE_REMARKABLE_DRAW   = 0x0018,
  TEMP_USE_MAX               = 0xFFFF
} display_temp;

typedef struct {
  uint32_t top;
  uint32_t left;
  uint32_t width;
  uint32_t height;
} mxcfb_rect;

typedef struct {
	uint32_t update_marker;
	uint32_t collision_test;
} mxcfb_update_marker_data;

typedef struct {
	uint32_t phys_addr;
	uint32_t width;                   /* width of entire buffer */
	uint32_t height;	                /* height of entire buffer */
	mxcfb_rect alt_update_region;	    /* region within buffer to update */
} mxcfb_alt_buffer_data;

typedef struct {
	mxcfb_rect update_region;
  uint32_t waveform_mode;

  // Choose between FULL and PARTIAL
  uint32_t update_mode;

  // Checkpointing
  uint32_t update_marker;

  int temp;                         // 0x1001 = TEMP_USE_PAPYRUS
  unsigned int flags;               // 0x0000


  /*
   * Dither mode is entirely unused since the following means v1 is used not v2
   *
   * arch/arm/configs/zero-gravitas_defconfig
      173:CONFIG_FB_MXC_EINK_PANEL=y

     firmware/Makefile
      68:fw-shipped-$(CONFIG_FB_MXC_EINK_PANEL) += \

     drivers/video/fbdev/mxc/mxc_epdc_fb.c
      4969:#ifdef CONFIG_FB_MXC_EINK_AUTO_UPDATE_MODE
      5209:#ifdef CONFIG_FB_MXC_EINK_AUTO_UPDATE_MODE

     drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c
      5428:#ifdef CONFIG_FB_MXC_EINK_AUTO_UPDATE_MODE
      5662:#ifdef CONFIG_FB_MXC_EINK_AUTO_UPDATE_MODE

     drivers/video/fbdev/mxc/Makefile
      10:obj-$(CONFIG_FB_MXC_EINK_PANEL)      += mxc_epdc_fb.o
      11:obj-$(CONFIG_FB_MXC_EINK_V2_PANEL)   += mxc_epdc_v2_fb.o
   *
   */
  int dither_mode;
	int quant_bit; // used only when dither_mode is > PASSTHROUGH and < MAX

  mxcfb_alt_buffer_data alt_buffer_data;  // not used when flags is 0x0000
} mxcfb_update_data;

typedef enum _mxcfb_dithering_mode {
	EPDC_FLAG_USE_DITHERING_PASSTHROUGH = 0x0,
	EPDC_FLAG_USE_DITHERING_DRAWING     = 0x1,
	// Dithering Processing (Version 1.0 - for i.MX508 and i.MX6SL)
  EPDC_FLAG_USE_DITHERING_Y1          = 0x002000,
  EPDC_FLAG_USE_REMARKABLE_DITHER     = 0x300f30,
  EPDC_FLAG_USE_DITHERING_Y4          = 0x004000

} mxcfb_dithering_mode;
]]
return {}
end)()
-- mkapp.lua: file module ==============================================================================
__LJClang_MkApp_Modules["remarkable"]=(function()

local ffi = require("ffi")
local C = ffi.C

local math = require("math")

local class = require("class").class
local error_util = require("error_util")
local check = error_util.check
local checktype = error_util.checktype
local input = require("input")

local FB = require("framebuffer")
local ioctl = FB.ioctl

local assert = assert
local type = type

require("remarkable_decls")

----------

local fb_var_screeninfo = ffi.typeof("struct fb_var_screeninfo")
local xywh_t = ffi.typeof("struct { uint32_t x, y, w, h; }")

-- NOTE: order is: top, left, width, height
local rect_t = ffi.typeof("mxcfb_rect")
local update_data_t = ffi.typeof("mxcfb_update_data")
local update_marker_data_t = ffi.typeof("mxcfb_update_marker_data")

-- The marker values appear to be system-global in the epdc_fb driver
-- (though note that we do pass a file descriptor),
-- so have an offset in the hope of avoiding collisions.
local MarkerOffset = 2^31

local function RequestRefresh(fd, vinfo,
                              rect, marker)
    assert(type(fd) == "number")
    assert(ffi.istype(fb_var_screeninfo, vinfo))

    check(ffi.istype(xywh_t, rect), "argument #1 must be a remarkable.xywh", 3)
    check(marker == nil or type(marker) == "number",
          "argument #2 must be nil or a number", 3)

    local mode = C.UPDATE_MODE_PARTIAL
    local waveform = C.WAVEFORM_MODE_GC16
    local displayTemp = C.TEMP_USE_REMARKABLE_DRAW

    local x, y = rect.x, rect.y

    -- NOTE: mxc_epdc_fb_send_single_update() errors on out-of-bounds values.
    check(x + rect.w <= vinfo.xres and y + rect.h <= vinfo.yres,
          "Update region out of bounds", 3)

    -- NOTE: Disallow empty update region. The driver does not like "odd" values.
    -- Observed in the kernel log when (0, 0, 0, 0) was passed:
    --
    --  Invalid drect width and height passed in
    --  imx_epdc_fb 20f4000.epdc: PxP operation failed due to timeout
    --  imx_epdc_fb 20f4000.epdc: Unable to complete PxP update task.
    --  pxp_dispatch_thread: task is timeout
    --
    --  WARNING: (...) at (...)/pxp_dma_v2.c:1496 pxp_alloc_chan_resources+0x5c/0x60
    check(rect.w > 0 and rect.h > 0, "Update region must not be empty", 3)

    local region = rect_t(y, x, rect.w, rect.h)

    local data = update_data_t(
        region, waveform, mode,
        (marker ~= nil) and MarkerOffset + marker or 0,
        displayTemp,
        0,  -- flags,
        0,  -- dither_mode (unused),
        0,  -- quant_bit (unused?)
        {}  -- alt_buffer_data, not used when flags == 0
    )

    ioctl(fd, C.MXCFB_SEND_UPDATE, data)
end

local function WaitForCompletion(fd,
                                 marker)
    checktype(marker, 1, "number", 3)

    local data = update_marker_data_t(MarkerOffset + marker, 0)
    ioctl(fd, C.MXCFB_WAIT_FOR_UPDATE_COMPLETE, data)
    return (data.collision_test ~= 0)
end

----------

local api = {
    xywh = xywh_t
}

local function MakeEventDevice()
    local MTC = input.MultiTouchCode
    local evd = input.EventDevice(1)
    evd:ioctl(input.EVIOC.SMASK, input.EV.ABS, {MTC.POSX, MTC.POSY, MTC.TRACKING_ID})
    return evd
end

api.Remarkable = class
{
    function(fb)
        if (fb == nil) then
            fb = FB.FrameBuffer(0, true)
        end

        -- NOTE: class type checking function would be nice.
        check(type(fb) == "table", "argument #1 must be nil or a FrameBuffer", 2)
        check(type(fb.line_length) == "number", "argument #1 must be nil or a FrameBuffer", 2)

        return {
            fb = fb,
            fd = assert(fb.fd),
            vinfo = fb:getVarInfo(),

            evd = nil,  -- input.EventDevice
        }
    end,

    getFrameBuffer = function(self)
        return self.fb
    end,

    openEventDevice = function(self)
        check(self.evd == nil, "must have no event device opened", 2)
        self.evd = MakeEventDevice()
        return self.evd
    end,

    closeEventDevice = function(self)
        check(self.evd ~= nil, "must have the event device opened", 2)
        self.evd:close()
        self.evd = nil
    end,

    requestRefresh = function(self, ...)
        return RequestRefresh(self.fd, self.vinfo, ...)
    end,

    waitForCompletion = function(self, ...)
        return WaitForCompletion(self.fd, ...)
    end,
}

-- Done!
return api
end)()
-- mkapp.lua: main =====================================================================================

-- Copyright (C) 2019-2020 Philipp Kutin

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

local ffi = require("ffi")

local bit = require("bit")
local io = require("io")
local math = require("math")
local os = require("os")

local class = require("class").class
local inet = require("inet")
local input = require("input")
local FrameBuffer = require("framebuffer").FrameBuffer
local JKissRng = require("jkiss_rng").JKissRng
local posix = require("posix")

local EV = input.EV
local POLL = posix.POLL

local assert = assert
local error = error
local ipairs = ipairs
local pairs = pairs
local pcall = pcall
local print = print
local require = require
local tonumber = tonumber
local tostring = tostring
local type = type
local unpack = unpack

local arg = arg
local stderr = io.stderr

local doFork = (arg[1] == "--fork")
if (doFork) then
    table.remove(arg, 1)
end

local isClient = (arg[1] == "c")
local isServer = (arg[1] == "s")
local hostNameOrAddr = isClient and arg[2] or nil
local acceptTimeoutMsArg = isServer and arg[2] or nil

local isAcceptTimeoutOk = not isServer or
    acceptTimeoutMsArg == nil or
    acceptTimeoutMsArg:match("^[1-9][0-9]*$")
local acceptTimeoutMs = isAcceptTimeoutOk and
    tonumber(acceptTimeoutMsArg) or nil

local function errprintf(fmt, ...)
    stderr:write((fmt.."\n"):format(...))
end

local function errprintfAndExit(fmt, ...)
    errprintf(fmt, ...)
    os.exit(1)
end

if (not ((isClient and hostNameOrAddr ~= nil) or (isServer and isAcceptTimeoutOk))) then
    if (not isAcceptTimeoutOk) then
        assert(isServer)
        errprintf("ERROR: timeout must be a non-negative integer.\n")
    end
    errprintf([[
Usage:
  %s [--fork] c <host name or IPv4 address>              # on the Raspberry Pi
  %s [--fork] s [<timeout waiting for connection (ms)>]  # on the reMarkable

When forking is requested, it is done:
 - for the client, after having connected.
 - for the server, just before the first accept() call.
In that case, the parent will exit with code zero to signal success.

A passed host name is resolved by reading and parsing /etc/hosts.
]], arg[0], arg[0])

    local quiet = (arg[1] == '-Q' and arg[2] == nil)
    if (quiet) then
        -- For the application unity file.
        require("remarkable")
    end
    os.exit(quiet and 0 or 1)
end

----------

-- Check the platform so that we do not mis-declare C structs or functions.
if (not (ffi.os == "Linux" and ffi.arch == "arm" and ffi.abi("32bit") and
         ffi.abi("le") and ffi.abi("hardfp") and ffi.abi("eabi"))) then
    errprintfAndExit("ERROR: This program is supposed to run on a 32-bit OS "..
                         "on the Raspberry Pi and on the reMarkable tablet.")
elseif (ffi.C.geteuid() == 0) then
    errprintfAndExit("ERROR: Refusing to run as root.")
end

ffi.cdef[[
int memcmp(const void *s1, const void *s2, size_t n);
]]

local function currentTimeMs()
    local ts = posix.clock_gettime()
    return 1000 * tonumber(ts.sec) + tonumber(ts.nsec) / 1000000
end

----------

local fb = FrameBuffer(0, isServer)
local map = fb:getMapping()
local unpackPixel = map:getUnpackPixelFunc()
local fbPtr = map:getBasePointer()

local SourcePixelSize = ffi.sizeof("uint32_t")
local DestPixelSize = ffi.sizeof("uint16_t")
local HalfwordSize = ffi.sizeof("uint16_t")

-- Are we running the server on something other than the reMarkable?
local isDebugging = (isServer and map:getPixelSize() == SourcePixelSize)

do
    local expectedPixelSize = (isClient and SourcePixelSize or DestPixelSize)

    if (not isDebugging and map:getPixelSize() ~= expectedPixelSize) then
        errprintfAndExit("ERROR: Unsupported pixel size.")
    end

    local vi = fb:getVarInfo()

    if (not (vi.blue.offset < vi.green.offset and vi.green.offset < vi.red.offset)) then
        errprintfAndExit("ERROR: Unexpected pixel component order.")
    end
end

local PixelArray = ffi.typeof("$ [?]", map:getPixelType())
local NarrowArray = ffi.typeof("uint16_t [?]")
local UInt32Array = ffi.typeof("uint32_t [?]")

local shl, shr = bit.lshift, bit.rshift
local band, bor = bit.band, bit.bor

-- Convert to RGB565 represented as integer.
-- NOTE: The order R-G-B is to be understood as from most to least significant bit.
--  (Thus, it is reverse to the order in terms of bit shift counts.)
local function narrow(px)
    local r, g, b = unpackPixel(px)
    return bor(shr(b, 3), shl(shr(g, 2), 5), shl(shr(r, 3), 11))
end

---------- Sampling and comparison ----------

-- Default screen dimensions on the reMarkable.
local ScreenWidth_rM = 1404
local ScreenHeight_rM = 1872
local MenuWidth_rM = 120
-- Guesstimate for the side length of the touch-active region around the rM "eye".
local EyeSize_rM = 128

-- Tiling on the source:
local SideLen = 8
local SquareSize = SideLen * SideLen  -- in pixels

-- Tiling on the target:
local BigSideLen = 2 * SideLen
local BigSquareSize = BigSideLen * BigSideLen

-- Encoding / decoding.
local IsRLE_Bit = bit.lshift(1, 15)
local IsDirect_Bit = bit.lshift(1, 14)
local EncodingType_Mask = IsRLE_Bit + IsDirect_Bit
local Count_Mask = IsDirect_Bit - 1
-- Encoding is per big tile, with the 16-bit header having the format (bit | count).
assert(BigSquareSize <= Count_Mask)

local uint32_t = ffi.typeof("uint32_t")

local function RoundToTarget(pixelLength)
    return tonumber(BigSideLen * uint32_t(pixelLength / BigSideLen))
end

local isRealServer = (isServer and not isDebugging)

if (isRealServer) then
    if (map.xres ~= ScreenWidth_rM or map.yres ~= ScreenHeight_rM) then
        errprintfAndExit("ERROR: Unexpected framebuffer dimensions.")
    end
end

local targetXres = math.min(RoundToTarget(map.xres), RoundToTarget(ScreenWidth_rM))
local targetYres = math.min(RoundToTarget(map.yres), RoundToTarget(ScreenHeight_rM))
local targetSize = targetXres * targetYres

-- We're OK with a portion of the screen clipped on the top, but want it whole on the bottom
-- where the menu bar is located.
local globalSrcYOffset = -map.yres % BigSideLen
assert(globalSrcYOffset >= 0 and globalSrcYOffset < BigSideLen)
-- Make sure we do not overwrite the "eye" on the reMarkable.
local DestYPixelOffset = EyeSize_rM
assert(DestYPixelOffset % BigSideLen == 0)  -- see usage for why

local StatusRectWidth = 64
-- X position of the rectangle signaling certain status conditions.
local StatusRectPosX = {
    OnError = EyeSize_rM,

    -- Requesting a shutdown of the connection from the rM.
    OnShutdown_rM_Init = ScreenWidth_rM / 2 - StatusRectWidth - 8,
    OnShutdown_rM_Finish = ScreenWidth_rM / 2 + 8,

    RightMarker = ScreenWidth_rM - 2 * EyeSize_rM,
}

local srcTileCountX = targetXres / SideLen
local srcTileCountY = targetYres / SideLen
local destTileCountX = targetXres / BigSideLen
local destTileCountY = targetYres / BigSideLen
local totalDestTileCount = destTileCountX * destTileCountY

print(("INFO: rounded %spicture dimensions: %d x %d"):format(
      isRealServer and "" or "target ", targetXres, targetYres))
print(("INFO: Tiled dimensions:"))
if (not isRealServer) then
    print(("INFO:  source:      %3d x %3d = %5d tiles (side length %d)"):format(
          srcTileCountX, srcTileCountY, (targetXres * targetYres) / SquareSize, SideLen))
end
print(("INFO: %s%3d x %3d = %5d tiles (side length %d)"):format(
      not isRealServer and " destination: " or "",
      destTileCountX, destTileCountY, totalDestTileCount, BigSideLen))

-- Throttling: Destination tiles for which changes were present within the last '...Window'
-- updates are tentatively held back until the sequence number is evenly divisible by the
-- period. This ensures that all updates for formerly held-back tiles are synchronized.
-- Note that in general this does not mean a fixed period in terms of wall-clock time since
-- we operate in varying time steps due to exponential backoff. However, for a video playing
-- whose content changes often enough, this will be approximately the case.
local FastFrameHoldBackWindow = 3
local FastFrameSendPeriod = 40

local isFrameThrottlingEnabled = true

local Sampler = class
{
    function()
        assert(targetSize % SquareSize == 0)
        local sampleCount = targetSize / SquareSize

        local screenCopyBuf = PixelArray(map:getRawSize())
        -- Fill with a value that initially will very likely invalidate all
        -- tiles. (NOTE: 0xff does not!)
        ffi.fill(screenCopyBuf, ffi.sizeof(screenCopyBuf), 0xfe)

        return {
            rng = JKissRng(),
            sampleCount = sampleCount,
            sampleBufs = {
                PixelArray(sampleCount),
                PixelArray(sampleCount),
            },

            currentSeqNum = FastFrameHoldBackWindow + 1,
            lastChangedSeqNums = UInt32Array(totalDestTileCount),
            lastSentSeqNums = UInt32Array(totalDestTileCount),

            -- exposed to Client
            screenCopyBuf = screenCopyBuf,
        }
    end,

    sampleAndCompare = function(self)
        local fbSampleBuf = self.sampleBufs[1]
        local scSampleBuf = self.sampleBufs[2]
        local screenCopyBuf = self.screenCopyBuf

        -- Generate sample indexes.
        local fbIndexes = self:generate()

        -- Sample.
        for i = 1, self.sampleCount do
            fbSampleBuf[i - 1] = fbPtr[fbIndexes[i]]
            scSampleBuf[i - 1] = screenCopyBuf[fbIndexes[i]]
        end

        -- Compare sample pixel values with current state!

        local currentSeqNum = self.currentSeqNum
        local blockedTileCount = 0
        local destTileCoords = {}

        -- NOTE: y first!
        for y = 0, destTileCountY - 1 do
            local xL, xlBlocked, xrBlocked, xR

            for x = 0, destTileCountX - 1 do
                -- NOTE: assumes that BigSideLen == 2 * SideLen:
                local sx, sy = 2*x, 2*y

                local srcSampleIdxs = {
                    srcTileCountX * sy + sx,
                    srcTileCountX * sy + sx + 1,
                    srcTileCountX * (sy + 1) + sx,
                    srcTileCountX * (sy + 1) + sx + 1,
                }

                local destTileIdx = destTileCountX * y + x
                local destTileChanged = false

                for _, si in ipairs(srcSampleIdxs) do
                    destTileChanged = destTileChanged or (fbSampleBuf[si] ~= scSampleBuf[si])
                end

                local lastChangedSeqNum = self.lastChangedSeqNums[destTileIdx]
                local lastSentSeqNum = self.lastSentSeqNums[destTileIdx]

                local isOutdated = destTileChanged or (lastSentSeqNum < lastChangedSeqNum)
                local wantHoldBack = destTileChanged and
                    (currentSeqNum <= lastChangedSeqNum + FastFrameHoldBackWindow)
                local canHoldBack = isFrameThrottlingEnabled and
                    wantHoldBack and (currentSeqNum % FastFrameSendPeriod ~= 0)
                local shouldSend = isOutdated and not canHoldBack

                xlBlocked = xlBlocked or (canHoldBack and x or nil)
                xrBlocked = (canHoldBack and x or nil) or xrBlocked

                if (destTileChanged) then
                    self.lastChangedSeqNums[destTileIdx] = currentSeqNum
                end

                if (shouldSend) then
                    self.lastSentSeqNums[destTileIdx] = currentSeqNum
                    xL = xL or x
                    xR = x
                end
            end

            if (xL ~= nil) then
                for xx = xL, xR do
                    local isBlocked =
                        (xlBlocked ~= nil and xx >= xlBlocked and xx <= xrBlocked)

                    blockedTileCount = blockedTileCount + (isBlocked and 1 or 0)
                    destTileCoords[#destTileCoords + 1] = {
                        x=xx, y=y, blocked=isBlocked
                    }
                end
            end
        end

        self.currentSeqNum = self.currentSeqNum + 1

        return destTileCoords, blockedTileCount
    end,

-- private:
    generate = function(self)
        local idxs = {}

        -- NOTE: y first!
        for y = 0, targetYres - 1, SideLen do
            for x = 0, targetXres - 1, SideLen do
                -- Randomly perturb sample positions.
                local xoff = self.rng:getu32() % SideLen
                local yoff = globalSrcYOffset + self.rng:getu32() % SideLen

                idxs[#idxs + 1] = map:getLinearIndex(x + xoff, y + yoff)
            end
        end

        assert(#idxs == self.sampleCount)
        return idxs
    end,
}

local function UnpackDestTileCoord(coord)
    local x, y = coord.x, coord.y
    assert(x >= 0 and x < destTileCountX)
    assert(y >= 0 and y < destTileCountY)
    return x, y
end

local CopyFormat = ffi.typeof[[struct {
    static const int Same = 1;
    static const int Packed = 2;
}]]

local function CopyBigTile(srcPtr, destPtr, coord, copyFormat)
    local keepFormat = (copyFormat == CopyFormat.Same)
    assert(keepFormat or copyFormat == CopyFormat.Packed)

    local tx, ty = UnpackDestTileCoord(coord)
    local sx = BigSideLen * tx
    local sy = BigSideLen * ty + globalSrcYOffset

    for i = 0, BigSideLen - 1 do
        local srcOffset = map:getLinearIndex(sx, sy + i)
        local destOffset = keepFormat and srcOffset or BigSideLen * i
        ffi.copy(destPtr + destOffset, srcPtr + srcOffset,
                 BigSideLen * SourcePixelSize)
    end
end

local function EncodeBigTile(tilePtr, codedBuf, offset)
    local codedBufSize = ffi.sizeof(codedBuf) / DestPixelSize
    local oldOffset = offset

    -- Check that we have room for one worst-case scenario.
    assert(offset + 1 + BigSquareSize <= codedBufSize)

    local isDirect = false  -- force new header on first encounter of direct case
    local curHeaderOffset = -1  -- direct case only

    local lastPixIdx = 0
    local curValue = tilePtr[lastPixIdx]

    -- For every pixel of the big tile...
    for i = 1, BigSquareSize do
        if (i == BigSquareSize or tilePtr[i] ~= curValue) then
            local runLength = i - lastPixIdx

            assert(runLength <= Count_Mask)

            if (runLength >= 4) then
                -- Run-length encoding.
                assert(offset + 2 <= codedBufSize)
                -- Always have a separate header.
                codedBuf[offset + 0] = IsRLE_Bit + runLength
                codedBuf[offset + 1] = curValue
                offset = offset + 2

                isDirect = false
            else
                -- Direct encoding.
                if (not isDirect) then
                    assert(offset < codedBufSize)
                    -- Need a new header.
                    codedBuf[offset] = IsDirect_Bit + runLength
                    curHeaderOffset = offset
                    offset = offset + 1
                else
                    -- Update the current header.
                    local hdrOff = curHeaderOffset
                    assert(hdrOff >= 0 and hdrOff < offset)
                    local headerValue = codedBuf[hdrOff]
                    assert(bit.band(headerValue, EncodingType_Mask) == IsDirect_Bit)
                    local oldCount = bit.band(headerValue, Count_Mask)
                    assert(oldCount + runLength <= Count_Mask)
                    codedBuf[hdrOff] = IsDirect_Bit + (oldCount + runLength)
                end

                assert(offset + runLength <= codedBufSize)

                for pi = 0, runLength - 1 do
                    codedBuf[offset + pi] = curValue
                end

                offset = offset + runLength
                isDirect = true
            end

            lastPixIdx = i
            curValue = tilePtr[i]
        end
    end

    -- Check that we added not more than the worst case worth of data.
    assert(offset - oldOffset <= 1 + BigSquareSize)

    return offset
end

local function checkData(cond, errMsg)
    assert(type(cond) == "boolean")
    assert(type(errMsg) == "string")

    if (not cond) then
        error(("Data validation error: %s\n"):format(errMsg))
    end
end

local function DecodeUpdates(inBuf, length, outBuf)
    local inBufSize = ffi.sizeof(inBuf) / DestPixelSize
    local outBufSize = ffi.sizeof(outBuf) / DestPixelSize

    checkData(length > 0 and length <= inBufSize, "invalid length")

    local srcOff, dstOff = 0, 0

    while (srcOff < length) do
        local header = inBuf[srcOff]

        local encodingType = bit.band(header, EncodingType_Mask)
        checkData(encodingType == IsRLE_Bit or encodingType == IsDirect_Bit,
                  "invalid header")

        local count = bit.band(header, Count_Mask)
        checkData(count > 0 and dstOff + count <= outBufSize, "invalid count 1")

        if (encodingType == IsDirect_Bit) then
            -- Direct encoding.
            checkData(srcOff + 1 + count <= inBufSize, "invalid count 2")

            for i = 0, count - 1 do
                outBuf[dstOff + i] = inBuf[srcOff + 1 + i]
            end

            srcOff = srcOff + 1 + count
        else
            -- Run-length encoding.
            checkData(srcOff + 1 < inBufSize, "invalid count 3")

            local value = inBuf[srcOff + 1]

            for i = 0, count - 1 do
                outBuf[dstOff + i] = value
            end

            srcOff = srcOff + 1 + 1
        end

        dstOff = dstOff + count
    end

    checkData(srcOff == length, "invalid decoding 1")
    checkData(dstOff > 0 and dstOff % BigSquareSize == 0, "invalid decoding 2")

    return dstOff / BigSquareSize
end

---------- Connection-related ----------

-- Mnemonic for the port number is "P2R" ("Pi to reMarkable").
local Port = 16218

-- Client -> server
local UpdateMagic = "UpDatE"

assert(totalDestTileCount <= 65536, "too high screen resolution")
-- NOTE: what matters is just that they are the same on both ends,
--  since we do not do any endianness conversions.
assert(ffi.abi("le"), "unexpected architecture")

-- Server -> client
local Cmd = {
    Length = 4,

    Enable = "Enbl",
    Disable = "Dsbl",
    Input = "Inpt",
    Ok = "_Ok_",
}

local UpdateHeader_t = ffi.typeof[[struct {
    char magic[6];
    uint16_t changedTileCount;
    uint32_t encodingLength;
}]]

local coord_t = ffi.typeof[[struct {
    uint16_t x, y;
}]]

local coord_array_t = ffi.typeof("$ [?]", coord_t)

local OurEventType = {
    SingleClick = 1,
    Drag = 2,
}

-- The amount of y travelled for sending one wheel up/down (9: 1mm).
local SingleWheelRollDistance = 81

local Button = {
    -- KEEPINSYNC with 'xdotool click' mouse button numbers:
    Left = 1,
    Middle = 2,
    Right = 3,
    WheelUp = 4,
    WheelDown = 5,

    -- These are for ourselves, 'xdotool' does not know them:
    VerticalDrag = 254,
    GenericDrag = 255
}

local OurEventDesc = {
    [OurEventType.SingleClick] = "single click",
    [OurEventType.Drag] = "drag",
}

local OurEvent_t = ffi.typeof[[struct {
    uint8_t ourType;
    uint8_t button;
    uint16_t x, y;
    uint16_t nx, ny;  // Drag only
}]]

----------

local function ConnectTo(socket, addrAndPort, displayName)
    local connFd, errMsg = socket:initiateConnection(addrAndPort)

    if (connFd == nil) then
        errprintfAndExit("ERROR: failed connecting to host %s: %s",
                         displayName, errMsg)
    end

    stderr:write(("INFO: connected to host %s\n"):format(displayName))

    return connFd
end

local function CheckCmdLength(length)
    if (length == 0) then
        errprintfAndExit("Connection to peer closed.")
    end

    assert(length == Cmd.Length, "unexpected command length")
end

local BackoffStepCount = 5
local MaxSleepTime = 500e3 -- microseconds
assert(MaxSleepTime < 1e6)  -- see usage for why

local timeval_t = ffi.typeof("struct timeval")

-- INPUT_EVENT_COORD_CONVERSION step 3
-- NOTE: Must be called on the client...
local function ConvertScreenToClient(sx, sy)
    local cx = sx
    local cy = sy - DestYPixelOffset
        + globalSrcYOffset  -- ...because of this!

    return cx, cy
end

local function InvokeXDoTool(commands)
    local whoami = posix.fork()

    if (whoami == "child") then
        assert(type(commands) == "table")
        posix.exec("/usr/bin/xdotool", commands)
    end
end


local MaxInputEvents = 1024
local sizeof_input_event = ffi.sizeof("struct input_event")
local input_event_array_t = ffi.typeof("struct input_event [?]")

local function ReadEvents(evd, inputBuf, maxAllowedSynValue, errnoAllowTab)
    local function readEventsIntoInputBuffer()
        if (errnoAllowTab == nil) then
            return evd.fd:readInto(inputBuf, true)
        else
            return evd.fd:readIntoAllowing(inputBuf, true, errnoAllowTab)
        end
    end

    local events, bytesRead = readEventsIntoInputBuffer()
    if (events == nil) then
        assert(errnoAllowTab ~= nil)
        -- NOTE: closing also sets evd.fd to -1. This is important for proper functioning
        --  after the keyboard has been unplugged, see INVALID_KB_EVD_FD.
        evd:close()
        return
    end

    assert(bytesRead % sizeof_input_event == 0)
    local eventCount = tonumber(bytesRead) / sizeof_input_event
    assert(eventCount > 0, "unexpected empty read")
    assert(eventCount < MaxInputEvents, "input event buffer overflow")

    local lastEvent = events[eventCount - 1]
    assert(lastEvent.type == EV.SYN and lastEvent.code == 0,
           "last read event is unexpectedly not a SYN_REPORT")
    assert(lastEvent.value <= maxAllowedSynValue,
           "unexpected value for final SYN_REPORT")

    return events, eventCount
end

local function GetAddress(nameOrQuad)
    assert(type(nameOrQuad) == "string")
    local IPAddressPattern = "([0-9]+)%.([0-9]+)%.([0-9]+)%.([0-9]+)"

    local a, b, c, d = nameOrQuad:match('^'..IPAddressPattern..'$')
    if (a ~= nil) then
        if (bit.bor(a, b, c, d) >= 256) then
            errprintfAndExit("ERROR: Invalid IPv4 address")
        end

        return {tonumber(a), tonumber(b), tonumber(c), tonumber(d)}
    end

    local HostNamePattern = "([a-z0-9][a-z0-9-]*)"

    if (nameOrQuad:match('^'..HostNamePattern..'$') == nil) then
        -- See 'man 7 hostname'.
        errprintfAndExit("ERROR: Invalid host name, must match "..HostNamePattern:sub(2, -2))
    end

    for line in io.lines("/etc/hosts") do
        local a, b, c, d, name = line:match(
            '^[ \t]*'..IPAddressPattern.."[ \t]+"..HostNamePattern..'[ \t]*$')
        if (a ~= nil and name == nameOrQuad) then
            return {tonumber(a), tonumber(b), tonumber(c), tonumber(d)}
        end
    end

    errprintfAndExit("ERROR: Host name not found in /etc/hosts")
end

local function FindKeyboardDevFile()
    local Directory = "/dev/input/by-path"
    local dir = posix.Dir(Directory)

    while (true) do
        local fileName = dir:read()
        if (fileName == nil) then
            return nil
        elseif (fileName:sub(-10,-1) == "-event-kbd") then
            return Directory.."/"..fileName
        end
    end
end

local function MaybeForkAndExit()
    if (doFork) then
        local whoami, pid = posix.fork()
        if (whoami == "parent") then
            print(("Child process ID: %d"):format(pid))
            os.exit(0)
        end
    end
end

local DummyKbEventDevice = class
{
    function()
        return {}
    end,

    getRawFd = function()
        return -1
    end,
}

local function GetKbEventDevice()
    local kbDevFileName = FindKeyboardDevFile()
    if (kbDevFileName == nil) then
        return DummyKbEventDevice()
    end

    local evDev = input.EventDevice(kbDevFileName)
    if (evDev.errMsg ~= nil) then
        io.stderr:write(("WARNING: failed opening keyboard event device file: %s\n")
                :format(evDev.errMsg))
        io.stderr:write(("INFO:    %s\n"):format(kbDevFileName))
        io.stderr:write("INFO:    Will not react to keyboard input.\n")
    end
    return evDev
end

local Client = class
{
    function()
        local address = GetAddress(hostNameOrAddr)
        address[#address + 1] = Port

        local kbEvDevice = GetKbEventDevice()
        local connFd = ConnectTo(inet.Socket(), address, hostNameOrAddr)

        MaybeForkAndExit()

        return {
            enabled = false,
            sampler = nil,  -- Sampler
            emptyStepCount = 0,

            tempBuf = PixelArray(targetSize),

            -- Updates in raw form:
            updateBuf = NarrowArray(targetSize),

            -- Run-length encoded updates. Encoding is per big tile.
            -- The format is sequence of items made up of halfword (16-bit) values:
            --
            --  [0] = (bit | count)  // header
            --
            --  if bit == IsDirect_Bit:
            --      itemCount := count
            --      [1 .. itemCount] = pixelValue
            --- if bit == IsRLE_Bit:
            --      repeatCount := count
            --      [1] = pixelValue
            --
            --  A run of pixel values is only encoded if <repeatCount> is at least 4, so
            --  that encoding always produces less data than directly writing out the pixel
            --  values and an additional header.
            --
            -- Worst cases:
            --  * uncompressible -> 1 + BigSquareSize halfwords
            --  * any combination of non-RLE and RLE sequences: not worse than uncompressed
            --    by construction
            --
            codedBuf = NarrowArray(totalDestTileCount * (1 + BigSquareSize)),

            connFd = connFd,

            kbEvDevice = kbEvDevice,
            inputBuf = input_event_array_t(MaxInputEvents),

            -- For debugging (non-connected run) only:
            decodedBuf_ = (connFd == nil) and NarrowArray(targetSize) or nil,
        }
    end,

    step = function(self)
        self:enable()

        local destTileCoords, blockedTileCount = self.sampler:sampleAndCompare()
        local updatedTileCount = #destTileCoords

        local packedTileCount = (updatedTileCount > 0) and
            self:captureUpdates(destTileCoords, self.sampler.screenCopyBuf) or 0
        assert(packedTileCount == updatedTileCount - blockedTileCount)

        if (packedTileCount > 0) then
            local encodingLength = self:encodeUpdates(packedTileCount)

            if (self.connFd ~= nil) then
                self:sendUpdates(destTileCoords, packedTileCount, encodingLength)
            else
                local fmt = "changed, #packedTiles=%d, encoded=%d halfwords (factor = %.03f)\n"
                stderr:write(fmt:format(packedTileCount, encodingLength,
                                        packedTileCount * BigSquareSize / encodingLength))
                local tileCount = DecodeUpdates(self.codedBuf, encodingLength, self.decodedBuf_)
                -- Check correctness of decoding.
                assert(tileCount == packedTileCount)
                assert(ffi.C.memcmp(self.updateBuf, self.decodedBuf_,
                                    tileCount * BigSquareSize * DestPixelSize) == 0)
            end

            self.emptyStepCount = 0
        else
            self.emptyStepCount = self.emptyStepCount + 1
        end

        -- Now, wait for the first of:
        --  * data ready to be read from the socket connected to the server, or
        --  * a timeout expiration.

        local sleepFactor =
            (2 ^ math.min(self.emptyStepCount, BackoffStepCount) - 1) /
            (2 ^ BackoffStepCount)

        local sleepTime = sleepFactor * MaxSleepTime
        local kbEvDevFd = self.kbEvDevice:getRawFd()

        local waitFds = {
            self.connFd and self.connFd.fd or -1,
            kbEvDevFd,
        }

        local fdSet = posix.fd_set_t()

        for _, fd in ipairs(waitFds) do
            if (fd >= 0) then
                fdSet:set(fd)
            end
        end

        local readyFdCount = ffi.C.select(math.max(unpack(waitFds)) + 1, fdSet, nil, nil,
                                          timeval_t(0, sleepTime))
        assert(readyFdCount >= 0, "unexpected system call error")

        if (readyFdCount > 0) then
            assert(readyFdCount <= #waitFds)

            if (kbEvDevFd >= 0 and fdSet:isSet(kbEvDevFd)) then
                ReadEvents(self.kbEvDevice, self.inputBuf, 1, { [posix.E.NODEV]=true })
            end

            if (self.connFd and fdSet:isSet(self.connFd.fd)) then
                -- TODO DISABLE_VIA_SERVER_INPUT: also allow Cmd.Disable
                self:receiveFromServerAndHandle(Cmd.Input)
            end
        end
    end,

-- private:
    captureUpdates = function(self, destTileCoords, screenCopyBuf)
        local updatedTileCount = #destTileCoords
        assert(updatedTileCount <= totalDestTileCount)
        local packedTileCount = 0

        for i, coord in ipairs(destTileCoords) do
            assert(i > 0 and i <= updatedTileCount)
            CopyBigTile(fbPtr, screenCopyBuf, coord, CopyFormat.Same)
            if (not coord.blocked) then
                local destPtr = self.tempBuf + BigSquareSize*packedTileCount
                CopyBigTile(screenCopyBuf, destPtr, coord, CopyFormat.Packed)
                packedTileCount = packedTileCount + 1
            end
        end

        local packedPixelCount = packedTileCount * BigSquareSize

        for i = 0, packedPixelCount - 1 do
            -- TODO: 'updated' in the top local does not mean the same as 'update' here.
            self.updateBuf[i] = narrow(self.tempBuf[i])
        end

        return packedTileCount
    end,

    encodeUpdates = function(self, updatedTileCount)
        assert(updatedTileCount <= totalDestTileCount)

        local updateBuf, codedBuf = self.updateBuf, self.codedBuf
        local offset = 0

        for tileIdx = 0, updatedTileCount - 1 do
            offset = EncodeBigTile(updateBuf + BigSquareSize * tileIdx,
                                   codedBuf, offset)
        end

        return offset
    end,

    sendUpdates = function(self, destTileCoords, changedTileCount, encodingLength)
        local connFd = self.connFd
        assert(connFd ~= nil)

        local header = UpdateHeader_t(UpdateMagic, changedTileCount, encodingLength)
        connFd:writeFull(header)

        local coords = coord_array_t(changedTileCount)

        local i = 0
        for _, coord in ipairs(destTileCoords) do
            if (not coord.blocked) then
                coords[i] = coord_t(coord.x, coord.y)
                i = i + 1
            end
        end

        assert(i == changedTileCount)

        connFd:writeFull(coords)
        connFd:writeFull(self.codedBuf, encodingLength * HalfwordSize)

        self:receiveFromServerAndHandle()
    end,

    enable = function(self)
        if (not self.enabled) then
            -- Wait for the server to allow sending it screen updates.
            local cmd = self:readCommand()
            checkData(cmd == Cmd.Enable, "unexpected command")

            self.enabled = true
            self.sampler = Sampler()
        end
    end,

    receiveFromServerAndHandle = function(self, singleAllowedCommand)
        assert(self.enabled)

        while (true) do
            local cmd = self:readCommand()

            checkData(singleAllowedCommand == nil or cmd == singleAllowedCommand,
                      "unexpected command")

            if (cmd == Cmd.Input) then
                -- NOTE SEND_INPUT_FIRST: sent by the server before a Disable or Ok!
                local ourEvent = self.connFd:readInto(OurEvent_t(), false)
                local cx, cy = ConvertScreenToClient(ourEvent.x, ourEvent.y)
                local cnx, cny = ConvertScreenToClient(ourEvent.nx, ourEvent.ny)

                local function isInScreenBounds(x, y)
                    return x >= 0 and x < targetXres and
                        y >= globalSrcYOffset and y < targetYres
                end

                if (cy >= targetYres and cny < globalSrcYOffset) then
                    -- Drag across the Pi screen from below it to above it: resend picture.
                    if (ourEvent.ourType == OurEventType.Drag) then
                        if (self.sampler ~= nil) then
                            self.sampler = Sampler()
                        end
                    end
                elseif (isInScreenBounds(cx, cy)) then
                    if (ourEvent.ourType == OurEventType.SingleClick) then
                        checkData(ourEvent.button >= Button.Left and ourEvent.button <= Button.Right,
                                  "unexpected server input event: unexpected button")

                        InvokeXDoTool{
                            "mousemove", tostring(cx), tostring(cy),
                            "click", tostring(ourEvent.button),
                            -- NOTE: to have feedback, deliberately no 'mousemove restore'.
                        }
                    elseif (ourEvent.ourType == OurEventType.Drag) then
                        if (ourEvent.button == Button.VerticalDrag) then
                            -- Emulate "dragging the page" like on a tablet by sending mouse
                            -- wheel up/down. Ideally, we would somehow issue the source and
                            -- destination coordinates directly to X. But there does not seem to
                            -- be a way to tell graphical programs to process them the way we
                            -- want generically (i.e. across a wide range of programs). Issuing
                            -- wheel up/down seems like a reasonable lowest common denominator.
                            local button = (cny > cy) and Button.WheelUp or Button.WheelDown
                            local repeatCount = math.floor(math.abs(cny - cy) / SingleWheelRollDistance)

                            if (repeatCount >= 1) then
                                InvokeXDoTool{
                                    "mousemove", tostring(cx), tostring(cy),
                                    "click", "--repeat", tostring(repeatCount), "--delay", "1", tostring(button),
                                    "mousemove", "restore"
                                }
                            end
                        elseif (ourEvent.button == Button.GenericDrag) then
                            if (isInScreenBounds(cnx, cny)) then
                                -- Emulate a drag with the left mouse button clicked.
                                InvokeXDoTool{
                                    "mousemove", tostring(cx), tostring(cy),
                                    "mousedown", tostring(Button.Left),
                                    "mousemove", tostring(cnx), tostring(cny),
                                    "mouseup", tostring(Button.Left)
                                }
                            end
                        else
                            checkData("unexpected server input event: unexpected drag type")
                        end
                    else
                        checkData(false, "unexpected server input event: invalid type")
                    end
                end

                if (singleAllowedCommand) then
                    -- We do not know if there is another event coming (most likely no)
                    -- and would block if no, so return.
                    -- TODO: make this (distinction of the two usage cases) prettier.
                    return
                end
            elseif (cmd == Cmd.Disable) then
                self.enabled = false
                self.sampler = nil
                return
            elseif (cmd == Cmd.Ok) then
                return
            else
                checkData(false, "unexpected command")
            end
        end
    end,

    readCommand = function(self)
        if (self.connFd == nil) then
            -- Just get the simulation going.
            return Cmd.Enable
        end

        -- NOTE: partial reads may happen, but so far observed only when peer is gone.
        --  (And then presumably with return value 0.)
        local cmd = self.connFd:read(Cmd.Length)
        CheckCmdLength(#cmd)
        return cmd
    end,
}

local ServerRequest = {
    Shutdown = 2,
}

local Server  -- class "forward-declaration"
local EyeData = nil

if (isRealServer) then
    local fd = ffi.C.open("rM_ul_eye_menu_hidden_46-28.dat", posix.O.RDONLY)
    if (fd == -1) then
        errprintfAndExit("ERROR: failed opening 'eye' screenshot data.")
    end

    fd = posix.Fd(fd)

    local pixelCount = 28 * 28
    EyeData = ffi.new("uint16_t [?]", pixelCount)
    fd:readInto(EyeData, false)
end

local function IsScreenDesired()
    assert(isServer)

    if (isRealServer) then
        local array = map:readRect(46, 46, 28, 28)
        assert(ffi.sizeof(array) == ffi.sizeof(EyeData))
        -- "Quick mode": we only wish that the Raspberry Pi screen is displayed if the main
        --  toolbar on the left hand side (when the rM is vertical) is hidden. Check this by
        --  comparing the pixels of the "eye".
        -- NOTE: we must take care not to compare too much around the "eye" since it becomes
        --  translucent from a certain radius onward.
        -- TODO: implement "marker document" mode.
        return (ffi.C.memcmp(array, EyeData, ffi.sizeof(EyeData)) == 0)
    else
        local Period = 5000
        return (uint32_t(currentTimeMs() / Period) % 2 == 0)
    end
end

local RM = isRealServer and require("remarkable") or nil
local xywh_t = RM and RM.xywh or nil

local RectSet = class
{
    function()
        return {
            rects = {}
        }
    end,

    add = function(self, rect)
        assert(ffi.istype(xywh_t, rect))

        local rects = self.rects
        rects[#rects + 1] = self.MergeHorizontally(rects[#rects], rect)
    end,

    finish = function(self)
        local oldRects = self.rects
        local newRects = {}

        for _, rect in ipairs(oldRects) do
            newRects[#newRects + 1] = self.MergeVertically(newRects[#newRects], rect)
        end

        self.rects = newRects
    end,

    getRects = function(self)
        return self.rects
    end,

-- static private:
    MergeHorizontally = function(lastRect, rect)
        if (lastRect ~= nil) then
            if (lastRect.y == rect.y and lastRect.h == rect.h and
                    rect.x == lastRect.x + lastRect.w) then
                -- Merge last update rect with incoming adjacent (next right) one.
                lastRect.w = lastRect.w + rect.w
                return nil
            end
        end

        return xywh_t(rect)
    end,

    MergeVertically = function(lastRect, rect)
        if (lastRect ~= nil) then
            if (lastRect.x == rect.x and lastRect.w == rect.w and
                    rect.y == lastRect.y + lastRect.h) then
                -- Merge last update rect with incoming adjacent (next below) one.
                lastRect.h = lastRect.h + rect.h
                return nil
            end
        end

        return xywh_t(rect)
    end,
}

--== All times in milliseconds.
local Duration = {
    MaxLeftClick = 500,
    -- Time that an initial tap must be held to commence generic (as opposed to
    -- vertical-only) dragging:
    GenericDragTapWait = 500,
}

local MaxSingleClickDeviation = 9  -- in delta x/y rM screen coordinates (9: 1 mm)

local Stage = {
    None = 0,
    Prefix = 1,
    Finished = 2,
}

-- Resolution of multitouch device.
local MtRes = {
    w = 0,
    h = 0,
}

-- Computed together with 'MtRes'.
local MultiTouchScreenUnitRatio

-- INPUT_EVENT_COORD_CONVERSION step 1
local function ObtainMultiTouchCoordRange(evd)
    local xRange = evd:ioctl(input.EVIOC.GABS.X)
    local yRange = evd:ioctl(input.EVIOC.GABS.Y)

    assert(xRange.minimum == 0 and yRange.minimum == 0,
           "unexpected multitouch device range x or y minimum")
    -- Check for something more than just 0 for extended sanity.
    -- NOTE: the ioctls report the both-sided *inclusive* range.
    assert(xRange.maximum >= 299 and yRange.maximum >= 399,
           "unexpected multitouch device range x or y maximum")

    MtRes.w = xRange.maximum + 1
    MtRes.h = yRange.maximum + 1

    MultiTouchScreenUnitRatio = MtRes.h / ScreenHeight_rM
end

-- INPUT_EVENT_COORD_CONVERSION step 2
local function ConvertMtToScreen(devx, devy)
    local isx = devx * ScreenWidth_rM / MtRes.w
    local isy = devy * ScreenHeight_rM / MtRes.h

    -- The MT device coordinates are flipped with respect to the
    -- framebuffer coordinates in both dimensions.
    local sx = ScreenWidth_rM - isx - 1
    local sy = ScreenHeight_rM - isy - 1

    -- NOTE: we may return fractional values here, but that's OK.
    assert(sx >= 0 and sx < ScreenWidth_rM)
    assert(sy >= 0 and sy < ScreenHeight_rM)

    return sx, sy
end

local function MakeEventToSend(ourEventType, ourData)
    local button = ourData.button
    local sx, sy = ConvertMtToScreen(ourData.x, ourData.y)
    assert(button ~= nil and sx ~= nil and sy ~= nil)

    local snx, sny = ConvertMtToScreen(ourData.nx, ourData.ny)
    assert(snx ~= nil and sny ~= nil)

    return OurEvent_t(ourEventType, button, sx, sy, snx, sny)
end

local MTC = input.MultiTouchCode

local InputState = class
{
    function()
        return {
            pressedCount = 0,
            -- The last time of the transition "no finger touches" -> one.
            -- (or infinity of not currently touching).
            lastFirstPressedTime = math.huge,

            stage = Stage.None,
            ourEventType = nil,
            ourData = nil,
            -- Set when starting dragging:
            onlyVerticalDrag = nil,
            isShutdownGesture = nil,
        }
    end,

    handleEventFrame = function(self, events, eventCount, outputTab,
                                specialRqTab)
        local oldStage = self.stage
        local didFinallyRelease = self:handlePressOrRelease(events, eventCount, specialRqTab)
        local hadProgress = (self.stage > oldStage)

        if (not hadProgress) then
            if (self.stage == Stage.Prefix) then
                local dragStartEventIdx = 0

                if (self.ourEventType == OurEventType.SingleClick) then
                    dragStartEventIdx = self:handleSingleClick(events, eventCount)
                end
                -- NOTE: not 'else if' because a single click can become a drag.
                if (self.ourEventType == OurEventType.Drag) then
                    self:handleDrag(events, dragStartEventIdx, eventCount)
                end
            end
        elseif (self.stage == Stage.Finished) then
            outputTab[1] = MakeEventToSend(self.ourEventType, self.ourData)
            self:reset()
        end

        if (didFinallyRelease) then
            self.lastFirstPressedTime = math.huge
        end
    end,

-- private:
    handleSingleClick = function(self, events, eventCount)
        local MaxDeviation = MaxSingleClickDeviation * MultiTouchScreenUnitRatio

        for i = 0, eventCount - 1 do
            local delta = self:updateNewPos(events[i])
            if (delta == nil) then
                self:reset()
                return eventCount
            end
            -- Allow a small deviation from the initially tapped point for
            -- "single click". If it is exceeded, consider it as starting...
            if (math.abs(delta) > MaxDeviation) then
                self.ourEventType = OurEventType.Drag  -- <- ...this.
                assert(self.lastFirstPressedTime ~= math.huge)

                local msSinceTap = currentTimeMs() - self.lastFirstPressedTime
                self.isShutdownGesture = self:isStartShutdownGesturePos()
                self.onlyVerticalDrag = (msSinceTap < Duration.GenericDragTapWait) or
                    self.isShutdownGesture
                return i + 1
            end
        end

        return eventCount
    end,

    isStartShutdownGesturePos = function(self)
        local sx, sy = ConvertMtToScreen(self.ourData.x, self.ourData.y)
        return (sx >= ScreenWidth_rM - EyeSize_rM and sy < EyeSize_rM)
    end,

    isEndShutdownGesturePos = function(self)
        local sx, sy = ConvertMtToScreen(self.ourData.nx, self.ourData.ny)
        return (sx >= ScreenWidth_rM - EyeSize_rM and sy >= ScreenHeight_rM - EyeSize_rM)
    end,

    handleDrag = function(self, events, startEventIdx, eventCount)
        local MinSlope = 3
        local TriangRegionCheckXOffset = SingleWheelRollDistance * MultiTouchScreenUnitRatio

        for i = startEventIdx, eventCount - 1 do
            if (self:updateNewPos(events[i]) == nil) then
                return self:reset()
            end

            local data = self.ourData
            local ody = data.ny - data.y

            if (self.onlyVerticalDrag) then
                local dx, dy = data.nx - data.x, data.ny - data.y
                -- After the initial single click tolerance, vertical dragging
                -- has to proceed (1) up or down consistently, and (2) in an
                -- allowed truncated-triangular region.
                local isInconsistentUpDown =
                    ody ~= 0 and (dy/ody < 0 or math.abs(dy) < math.abs(ody))
                local isOutsideTriangle =
                    (math.abs(dx) > TriangRegionCheckXOffset and
                     math.abs(dy) / (math.abs(dx) - TriangRegionCheckXOffset) < MinSlope)

                if (isInconsistentUpDown or isOutsideTriangle) then
                    return self:reset()
                end
            end
        end
    end,

    updateNewPos = function(self, event)  --> delta
        local MemberTab = { [MTC.POSX]='x', [MTC.POSY]='y' }
        local m = MemberTab[event.code]
        if (m == nil) then
            return nil
        end
        local newValue = event.value
        self.ourData['n'..m] = newValue  -- update 'new' coordinate
        return newValue - self.ourData[m]
    end,

    handlePressOrRelease = function(self, events, eventCount, specialRqTab)  --> "did finally release?"
        local pressedCountDelta = self:getPressedCountDelta(events, eventCount)
        if (pressedCountDelta == 0) then
            return false
        end

        local oldPressedCount = self.pressedCount

        self.pressedCount = oldPressedCount + pressedCountDelta
        -- FIXME: can fail on hiding rM menu after having connected when it was visible.
        assert(self.pressedCount >= 0, "more touch release than press events")

        local haveInitiallyPressed = (oldPressedCount == 0 and pressedCountDelta > 0)
        local haveFinallyReleased = (oldPressedCount > 0 and self.pressedCount == 0)

        if (haveInitiallyPressed) then
            self.lastFirstPressedTime = currentTimeMs()
        end

        if (self.pressedCount > 1) then
            -- We do not currently allow multi-finger gestures.
            self:reset()
        elseif (self.stage == Stage.None and haveInitiallyPressed) then
            self:handleInitialPress(events, eventCount)
        elseif (self.stage == Stage.Prefix and haveFinallyReleased) then
            self:handleFinalRelease(eventCount, specialRqTab)
        end

        return haveFinallyReleased
    end,

    handleInitialPress = function(self, events, eventCount)
        -- First finger down: begin single click, but only we get all coordinates with the
        -- first input frame.
        if (eventCount >= 3 and
                events[1].code == MTC.POSX and
                events[2].code == MTC.POSY) then
            self.stage = Stage.Prefix
            self.ourEventType = OurEventType.SingleClick
            self.ourData = {
                x = events[1].value,
                y = events[2].value,
                -- For Drag -- the destination ("new") coordinates.
                nx = events[1].value,
                ny = events[2].value
            }
        end
    end,

    handleFinalRelease = function(self, eventCount, specialRqTab)
        -- Last finger up: May finish a gesture in progress, but only if there are no
        -- additional events in the input frame.
        if (eventCount ~= 1) then
            self:reset()
        elseif (self.ourEventType == OurEventType.SingleClick) then
            local isAlternative = self:timedOut(Duration.MaxLeftClick)
            self.ourData.button = isAlternative and Button.Right or Button.Left
            self.stage = Stage.Finished
        elseif (self.ourEventType == OurEventType.Drag) then
            if (self.isShutdownGesture) then
                if (self:isEndShutdownGesturePos()) then
                    specialRqTab[1] = ServerRequest.Shutdown
                end
                self:reset()
            else
                self.ourData.button =
                    self.onlyVerticalDrag and Button.VerticalDrag or Button.GenericDrag
                self.stage = Stage.Finished
            end
        end
    end,

    timedOut = function(self, maxDuration)
        return currentTimeMs() >= self.lastFirstPressedTime + maxDuration
    end,

    getPressedCountDelta = function(self, events, eventCount)
        assert(eventCount > 0)

        local totalDelta = 0

        for i = 0, eventCount - 1 do
            local ev = events[i]
            assert(ev.type == EV.ABS, "unexpected event type")

            if (ev.code == input.MultiTouchCode.TRACKING_ID) then
                local delta = (ev.value >= 0) and 1 or -1

                totalDelta = totalDelta + delta
                -- We do not expect a frame to have both presses and releases.
                assert((totalDelta > 0) == (delta > 0))
            end
        end

        return totalDelta
    end,

    reset = function(self)
        self.stage = Stage.None
        self.ourEventType = nil
        self.ourData = nil
        self.onlyVerticalDrag = nil
        self.isShutdownGesture = nil
    end,
}

Server = class
{
    function()
        local connFd, errMsg = inet.Socket():expectConnection(
            Port, acceptTimeoutMs, MaybeForkAndExit)
        if (connFd == nil) then
            errprintfAndExit("ERROR: failed awaiting connection: %s", errMsg)
        end

        return {
            connFd = connFd,
            enabled = false,

            rM = RM.Remarkable(fb),
            evd = nil,  -- input.EventDevice or DummyKbEventDevice
            inputBuf = input_event_array_t(MaxInputEvents),
            inputState = nil,  -- InputState
            specialRequestTab = { nil },  -- can be one of the 'ServerRequest' constants

            decodedBuf = NarrowArray(targetSize),
        }
    end,

    step = function(self)
        self:mainLoopStep()
    end,

    clearUpperArea = function(self)
        local x, y = MenuWidth_rM, 0
        local w, h = ScreenWidth_rM - MenuWidth_rM, DestYPixelOffset
        map:fill(x, y, w, h, 0xffff)
        self.rM:requestRefresh(xywh_t(x, y, w, h))
    end,

    drawStatusRect = function(self, x)
        assert(type(x) == "number")
        local y, w = 32, StatusRectWidth
        map:fill(x, y, w, w, 15 + 32*31 + 32*64*15)
        self.rM:requestRefresh(xywh_t(x, y, w, w))
    end,

    shutDownAndExit = function(self, exitCode)
        -- NOTE: do not disable, need DISABLE_VIA_SERVER_INPUT for that.

        self.connFd:shutdown(posix.SHUT.RDWR)
        self:drawStatusRect(StatusRectPosX.OnShutdown_rM_Init)

        repeat
            local str = self.connFd:read(256)
        until (#str == 0)

        self:drawStatusRect(StatusRectPosX.OnShutdown_rM_Finish)
        os.exit(exitCode)
    end,

-- private:
    mainLoopStep = function(self)
        self:enable()

        -- Wait for input on either the multitouch device or from the network.

        -- NOTE [INVALID_KB_EVD_FD]: 'evdFd' may be -1, either because we were started with
        --  no keyboard to begin with, or because we had one when we started, but it was
        --  unplugged later.
        local connFd, evdFd = self.connFd.fd, self.evd:getRawFd()

        local pollfds = posix.poll{ events=POLL.IN, connFd, evdFd }
        assert(#pollfds == 1 or #pollfds == 2)

        local haveFd = {}
        for _, pollfd in ipairs(pollfds) do
            haveFd[pollfd.fd] = true
        end

        assert(haveFd[connFd] or haveFd[evdFd])

        -- Handle received input(s) -- from the network (client) or the multitouch device.
        local updateData = haveFd[connFd] and self:receiveUpdates() or nil
        local inputData = haveFd[evdFd] and self:getInput() or nil

        -- Carry out should-disable check only when we have received updates.
        -- TODO [DISABLE_VIA_SERVER_INPUT]: also allow Cmd.Disable
        if (updateData ~= nil) then
            self:maybeDisable()

            if (not self.enabled) then
                -- NOTE: it may happen that we omit sending a mouse-up event and leave the
                --  client in an odd state.
                return
            end
        end

        -- Apply results.

        if (inputData ~= nil) then
            -- NOTE [SEND_INPUT_FIRST]: Send input first so that the Ok from the application
            --  of the updates (if present) arrives last.
            self:sendInput(inputData)
        end

        if (updateData ~= nil) then
            self:applyUpdates(updateData[1], updateData[2], self.decodedBuf)
        end

        do
            -- Handle special requests.
            local specialRequest = self.specialRequestTab[1]

            if (specialRequest == ServerRequest.Shutdown) then
                self:shutDownAndExit(0)
            end
        end
    end,

    getInput = function(self)
        local events, eventCount = ReadEvents(self.evd, self.inputBuf, 0)
        local eventToSend = {}
        local lastIdx = 0

        for i = 0, eventCount - 1 do
            local ev = events[i]

            if (ev.type == EV.SYN) then
                assert(i > lastIdx, "unexpected empty event frame")
                self.inputState:handleEventFrame(events + lastIdx, i - lastIdx, eventToSend,
                                                 self.specialRequestTab)
                lastIdx = i + 1
            end
        end

        return eventToSend[1]
    end,

    sendInput = function(self, data)
        local connFd = self.connFd
        assert(ffi.istype(OurEvent_t, data))

        local bytesWritten = connFd:write(Cmd.Input)
        assert(bytesWritten == Cmd.Length, "FIXME: partial write")

        connFd:writeFull(data)
    end,

    receiveUpdates = function(self)
        local connFd = self.connFd

        local header = connFd:readInto(UpdateHeader_t(), false)
        checkData(ffi.string(header.magic, #UpdateMagic) == UpdateMagic,
                  "magic bytes mismatch")

        -- TODO: preallocate the two arrays?

        local changedTileCount = header.changedTileCount
        local coords = connFd:readInto(coord_array_t(changedTileCount), false)

        local encodingLength = header.encodingLength
        local encodedData = connFd:readInto(NarrowArray(header.encodingLength), false)

        local tileCount = DecodeUpdates(encodedData, encodingLength, self.decodedBuf)
        checkData(tileCount == changedTileCount, "corrupt encoding: tile count mismatch")

        return { tileCount, coords }
    end,

    applyUpdates = function(self, tileCount, tileCoords, tileBuf)
        checkData(tileCount * BigSquareSize <= ffi.sizeof(tileBuf) / DestPixelSize,
                  "too many updated tiles")

        local yTileOffset = DestYPixelOffset / BigSideLen
        local updateRectSet = RectSet()

        for i = 0, tileCount - 1 do
            local tx, ty = tileCoords[i].x, tileCoords[i].y
            checkData(tx < destTileCountX and ty < destTileCountY,
                      "tile coordinates out of bounds")
            ty = ty + yTileOffset

            if (ty < destTileCountY) then
                local rect = xywh_t(BigSideLen * tx, BigSideLen * (ty),
                                    BigSideLen, BigSideLen)
                updateRectSet:add(rect)

                -- Write updated tile to the framebuffer.
                map:writeRect(rect.x, rect.y, rect.w, rect.h, tileBuf + BigSquareSize * i)
            end
        end

        updateRectSet:finish()
        local updateRects = updateRectSet:getRects()

        -- Request update of the changed screen portions.
        for i, rect in ipairs(updateRects) do
            self.rM:requestRefresh(rect, i)
        end

        -- Wait for the updates to finish.
        for i, _ in ipairs(updateRects) do
            self.rM:waitForCompletion(i)
        end

        local bytesWritten = self.connFd:write(Cmd.Ok)
        assert(bytesWritten == Cmd.Length, "FIXME: partial write")
    end,

    enable = function(self)
        if (not self.enabled) then
            while (not IsScreenDesired()) do
                posix.clock_nanosleep(500e6)
            end

            if (isRealServer) then
                self:clearUpperArea()
                -- TODO: draw the rM "cross in circle"?
            end

            local bytesWritten = self.connFd:write(Cmd.Enable)
            assert(bytesWritten == Cmd.Length, "FIXME: partial write")
            self.enabled = true

            self.evd = self.rM:openEventDevice()
            ObtainMultiTouchCoordRange(self.evd)
            self.inputState = InputState()
        end
    end,

    maybeDisable = function(self)
        assert(self.enabled)
        self.enabled = IsScreenDesired()

        if (not self.enabled) then
            local bytesWritten = self.connFd:write(Cmd.Disable)
            assert(bytesWritten == Cmd.Length, "FIXME: partial write")

            self.rM:closeEventDevice()
            self.evd = nil

            -- TODO: clear? (E.g. if in pressed state, send as many release events.)
            self.inputState = nil
        end
    end,
}

local app = isClient and Client() or Server()

----------

local function main()
    while (true) do
        local startMs = currentTimeMs()
        app:step()

        if (not (isClient or isRealServer)) then
            io.stdout:write(("%.0f ms\n"):format(currentTimeMs() - startMs))
        end
    end
end

local ok, errMsg = pcall(main)
if (not ok) then
    if (io.open(".ljrM-enable-error-log") ~= nil) then
        local f = io.open("ljrM-error.log", "a+")
        if (f ~= nil) then
            local Sep = ('='):rep(30)
            local d = os.date("*t")
            local dateStr = ("%d-%02d-%02d %02d:%02d:%02d"):format(
                d.year, d.month, d.day, d.hour, d.min, d.sec)
            f:write(("\n%s %s %s\n"):format(Sep, dateStr, Sep))
            f:write(errMsg..'\n')
            f:close()
        end
    end

    if (isRealServer) then
        app:drawStatusRect(StatusRectPosX.OnError)
        stderr:write(errMsg..'\n')
        app:shutDownAndExit(101)
    end

    error(errMsg)
end
